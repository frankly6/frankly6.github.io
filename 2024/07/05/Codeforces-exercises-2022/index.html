<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Codeforces exercises 2022 - frankly6</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="frankly6"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="frankly6"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="记录了22&amp;#x2F;5&amp;#x2F;31-22&amp;#x2F;11&amp;#x2F;20的三十七场 codeforces 补题, \(rating \;1568\rightarrow1906\)​   文章因为过于陈旧已不再受维护"><meta property="og:type" content="blog"><meta property="og:title" content="Codeforces exercises 2022"><meta property="og:url" content="http://example.com/2024/07/05/Codeforces-exercises-2022/"><meta property="og:site_name" content="frankly6"><meta property="og:description" content="记录了22&amp;#x2F;5&amp;#x2F;31-22&amp;#x2F;11&amp;#x2F;20的三十七场 codeforces 补题, \(rating \;1568\rightarrow1906\)​   文章因为过于陈旧已不再受维护"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2024-07-05T13:35:14.000Z"><meta property="article:modified_time" content="2025-03-27T11:13:02.386Z"><meta property="article:author" content="Frankly6"><meta property="article:tag" content="C++"><meta property="article:tag" content="编程竞赛"><meta property="twitter:card" content="summary"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2024/07/05/Codeforces-exercises-2022/"},"headline":"Codeforces exercises 2022","image":[],"datePublished":"2024-07-05T13:35:14.000Z","dateModified":"2025-03-27T11:13:02.386Z","author":{"@type":"Person","name":"Frankly6"},"publisher":{"@type":"Organization","name":"frankly6","logo":{"@type":"ImageObject","url":"http://example.com/img/logo.svg"}},"description":"记录了22&#x2F;5&#x2F;31-22&#x2F;11&#x2F;20的三十七场 codeforces 补题, \\(rating \\;1568\\rightarrow1906\\)​\r \r \r 文章因为过于陈旧已不再受维护"}</script><link rel="canonical" href="http://example.com/2024/07/05/Codeforces-exercises-2022/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link data-pjax rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link data-pjax rel="stylesheet" href="/css/default.css"><!--!--><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdnjs.loli.net/ajax/libs/pace/1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const id = '#' + CSS.escape(location.hash.substring(1));
          const $tabMenu = document.querySelector(`.tabs a[href="${id}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(id);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="frankly6" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time datetime="2024-07-05T13:35:14.000Z" title="2024-07-05T13:35:14.000Z">2024-07-05</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time datetime="2025-03-27T11:13:02.386Z" title="2025-03-27T11:13:02.386Z">2025-03-27</time></span><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/">算法竞赛</a></span><span class="level-item">3 小时读完 (大约26364个字)</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">Codeforces exercises 2022</h1><div class="content"><p>记录了22/5/31-22/11/20的三十七场 codeforces 补题, <span
class="math inline">\(rating \;1568\rightarrow1906\)</span>​</p>
<article class="message message-immersive is-warning">
<div class="message-body">
<p><i class="fas fa-exclamation-circle mr-2"></i>文章因为过于陈旧已不再受维护</p>
</div>
</article>
<span id="more"></span>
<h2 id="codeforces-round-795-div2-22531"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1691">codeforces round 795 (#Div2)
22/5/31</a></h2>
<p><span class="math inline">\((1568\rightarrow1532,
rk3394)\)</span><br />
这几场都打的很寄, 例行只会ABC,
stl不会用,场上一共寄了六发,都是各种边界条件……</p>
<h3 id="d"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1691/problem/D">D</a></h3>
<p>题意：<br />
给定长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a (-10^9\leq a_{i} \leq 10^9)\)</span>,
问是否能找到一段区间 <span class="math inline">\([L,R]\)</span> 使得
<span
class="math inline">\(max([L,R])&lt;\sum\limits_{i=L}^{R}a_{i}\)</span><br />
思路：<br />
区间的选择有 <span class="math inline">\(n^2\)</span> 种,
区间最大值的选择只有 <span class="math inline">\(n\)</span> 种,
因此要枚举所有的 区间最大值, 然后让包含它的区间最大。<br />
流程：<br />
<span class="math inline">\(1.\)</span> 单调栈找到每个 <span
class="math inline">\(a_{i}\)</span> 第一个左边比它大的数 <span
class="math inline">\(L_{i}\)</span> 与右边比它大的数<span
class="math inline">\(R_{i}\)</span> <span
class="math inline">\(2.\)</span> 对 <span
class="math inline">\(a\)</span> 做前缀和, 对 <span
class="math inline">\(pre\)</span> 建线段树, 找到 <span
class="math inline">\([i,R_{i}-1]\)</span> 中的最大值和<span
class="math inline">\([L_{i},i-1]\)</span>中的最小值, 两个相减得到包含
<span class="math inline">\(a_{i}\)</span> 的最大区间。<br />
代码注意：线段树下标从 <span class="math inline">\(0\)</span> 开始,
记得开 <span class="math inline">\(long\)</span> <span
class="math inline">\(long\)</span></p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) l[i]=r[i]=<span class="number">0</span>; top=<span class="number">0</span>;</span><br><span class="line">N=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>();</span><br><span class="line">ar[N+<span class="number">1</span>]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N+<span class="number">1</span>;i++)&#123;</span><br><span class="line">	<span class="keyword">while</span>(top&amp;&amp;ar[stac[top]]&lt;ar[i])&#123; <span class="comment">//单调栈, 看每个 a[i] 对左边的影响</span></span><br><span class="line">		r[stac[top]]=i; <span class="comment">// 左边的 a[stac[top]] 找到右边第一个比他大的数 a[i] </span></span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">	stac[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line">top=<span class="number">0</span>; ar[<span class="number">0</span>]=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=N;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	<span class="keyword">while</span>(top&amp;&amp;ar[stac[top]]&lt;ar[i])&#123;</span><br><span class="line">		l[stac[top]]=i; <span class="comment">// 右边的 a[stac[top]] 找到左边第一个比他大的数 a[i] </span></span><br><span class="line">		top--;</span><br><span class="line">	&#125;</span><br><span class="line">	stac[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">	pre[i]=pre[i<span class="number">-1</span>]+ar[i];  			</span><br><span class="line"><span class="built_in">bt</span>(<span class="number">1</span>,<span class="number">0</span>,N);</span><br><span class="line"><span class="type">int</span> ck=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	<span class="type">int</span> t1=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">0</span>,N,i,r[i]<span class="number">-1</span>,<span class="number">1</span>), t2=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">0</span>,N,l[i],i<span class="number">-1</span>,<span class="number">2</span>); <span class="comment">//线段树求最值, 略</span></span><br><span class="line">	<span class="keyword">if</span>(ar[i]&lt;t1-t2) &#123;ck=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ck==<span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>是个好题, 告诉我们做题要找简单切入点, 不要盯着 <span
class="math inline">\(n^2\)</span> 的区间选择看……</p>
<h3 id="e"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1691/problem/E">E</a></h3>
<p>题意：<br />
<span class="math inline">\(N\)</span> 条线段, 两种不同的颜色,
若不同颜色的线段有交集则说明是联通的(一个交点也算),
问有多少个连通块。</p>
<p>思路：<br />
好想，难写(对于我这个不会用STL的菜鸡)。<br />
暴力连边 <span class="math inline">\(O(N^2)\)</span> 不可取,
尝试排序线段端点，带删连边。<br />
我们可以把一条线段拆成左右两端点, 到左端点时加入, 右端点时删除, 存入两个
<span class="math inline">\(set\)</span> 中(代表两个不同颜色),
加入左端点时, 若另一个 <span class="math inline">\(set\)</span>
中还有元素(另一个 <span class="math inline">\(set\)</span>
中的线段都包含这个左端点), 则全部合并, 因为全部合并, 可以将另一个 <span
class="math inline">\(set\)</span>
中的元素删除到仅剩一个右端点最大的元素为止, 最后统计连通块数目。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">seg</span> &#123;<span class="type">int</span> l, r, col, pos;&#125;; </span><br><span class="line">seg ar[MX];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	T=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		N=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) fa[i]=i;</span><br><span class="line">		vector&lt;PII&gt; op;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="type">int</span> col=<span class="built_in">read</span>(), l=<span class="built_in">read</span>(), r=<span class="built_in">read</span>();</span><br><span class="line">			ar[i]=(seg)&#123;l,r,col,i&#125;;</span><br><span class="line">			op.<span class="built_in">push_back</span>(&#123;l,-i&#125;); <span class="comment">//use &quot;i&quot; and &quot;-i&quot;, we can easily discern the left or right endpoint</span></span><br><span class="line">			op.<span class="built_in">push_back</span>(&#123;r,i&#125;); <span class="comment">// STL pair will compare the second keyword if the first keyword is the same</span></span><br><span class="line">		&#125;						 <span class="comment">// so we MUST set the left endpoint -i, because we can connect segments with the same endpoint (not the same side) too.</span></span><br><span class="line">		<span class="built_in">sort</span>(op.<span class="built_in">begin</span>(),op.<span class="built_in">end</span>()); <span class="comment">//By the default order, the first element of the pair.</span></span><br><span class="line">		set&lt;PII&gt; s[<span class="number">2</span>]; <span class="comment">//Store two colors.</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> it=op.<span class="built_in">begin</span>();it!=op.<span class="built_in">end</span>();it++) <span class="comment">//The nobel auto guides us.</span></span><br><span class="line">		&#123;	<span class="comment">//&quot;auto [pos,id] : op&quot; is an alternative option by tourist, only works on c++17 (Structured binding declaration)</span></span><br><span class="line">			PII tmp=*it; </span><br><span class="line">			<span class="type">int</span> pos=tmp.first;</span><br><span class="line">			<span class="type">int</span> id=tmp.second;</span><br><span class="line">			<span class="keyword">if</span>(id&lt;<span class="number">0</span>)&#123; <span class="comment">//left endpoint, add it	</span></span><br><span class="line">				id=-id;</span><br><span class="line">				s[ar[id].col].<span class="built_in">insert</span>(&#123;ar[id].r,id&#125;);</span><br><span class="line">				<span class="type">int</span> t=ar[id].col^<span class="number">1</span>; <span class="comment">//another color</span></span><br><span class="line">				<span class="keyword">while</span>(s[t].<span class="built_in">size</span>()&gt;<span class="number">1</span>)&#123; <span class="comment">//find in the another set</span></span><br><span class="line">					<span class="built_in">merge</span>(id,s[t].<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line">					s[t].<span class="built_in">erase</span>(s[t].<span class="built_in">begin</span>());</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(!s[t].<span class="built_in">empty</span>()) <span class="built_in">merge</span>(id,s[t].<span class="built_in">begin</span>()-&gt;second);</span><br><span class="line"> 			&#125;</span><br><span class="line">			<span class="keyword">else</span> s[ar[id].col].<span class="built_in">erase</span>(&#123;ar[id].r,id&#125;); <span class="comment">//right endpoint, delete it</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) res += (<span class="built_in">find</span>(i)==i);</span><br><span class="line">		cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几点想说：<br />
1、<span class="math inline">\(auto\)</span> 真好用, <span
class="math inline">\(set\)</span> 真香, 这里 <span
class="math inline">\(pair\)</span> 换 <span
class="math inline">\(struct\)</span> 也可以, 记得 <span
class="math inline">\(set\)</span> 里存的右端点。</p>
<p>2、代码是改 <span class="math inline">\(tourist\)</span> 的,
在拆端点时记得给左边赋 <span class="math inline">\(-i\)</span>
,因为有一个交点也算连通块。</p>
<p>3、这题拖了一个月, 因为一开始 STL 蛋都不懂。</p>
<h2 id="codeforces-round-796-div2-2263"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1688">codeforces round 796 (#Div2)
22/6/3</a></h2>
<p><span class="math inline">\((1532\rightarrow1639,
rk438)\)</span><br />
全场贪心(指我会的ABCD), 猜了一个结论, E最小生成树全忘了, 到时候复健一下,
F很有趣, 但不会。场上只寄了一发F, 但A题写了19mins,
下次思考完再动手……</p>
<h3 id="e-div1-b"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1688/problem/E">E (Div1 B)</a></h3>
<p>复健了一下……<br />
交互题 题意:<br />
<span class="math inline">\(N\)</span> 个点, <span
class="math inline">\(M\)</span> 条边的图(不一定联通), <span
class="math inline">\(2M\)</span> 次询问, 每次自由加一些边,
告诉你最大生成树林的边权和, 你要最后回答最小生成树林的边权和。</p>
<p>思路：<br />
先用 <span class="math inline">\(M\)</span> 个类似 <span
class="math inline">\(0000...0010...0000\)</span>
的字符串求出每一条边的边长, 从小到大排序一下, 再贪心 <span
class="math inline">\(M\)</span> 次尝试一条条加回去,
如果加回去后返回的最大森林边权和等于目前的答案加上加入的那条边的边权,
则说明新加入的这条边联通了两个块, 应该保留, (类似 <span
class="math inline">\(kruskal\)</span> 的思想), 最后输出答案。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); M=<span class="built_in">read</span>();</span><br><span class="line">string str;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++) str+=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;M;i++)</span><br><span class="line">&#123;</span><br><span class="line">	str[i]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	cin &gt;&gt; e[++cnt].d;</span><br><span class="line">	e[cnt].pos=cnt;</span><br><span class="line">	str[i]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(e+<span class="number">1</span>,e+<span class="number">1</span>+M);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp=<span class="number">0</span>;</span><br><span class="line">	str[e[i].pos<span class="number">-1</span>]=<span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;? &quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">	<span class="built_in">fflush</span>(stdout);</span><br><span class="line">	cin &gt;&gt; tmp;		</span><br><span class="line">	<span class="keyword">if</span>(tmp==ans+e[i].d) ans=tmp;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(tmp!=ans+e[i].d) str[e[i].pos<span class="number">-1</span>]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;! &quot;</span> &lt;&lt; ans &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<h3 id="f-div1-c"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1688/problem/F">F (Div1 C)</a></h3>
<p>题意：<br />
给定两个长为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span>, <span
class="math inline">\(b\)</span>, 再给 <span
class="math inline">\(m\)</span> 个区间 <span
class="math inline">\([l_{i}, r_{i}]\)</span> , 每次操作可以选择一个
<span
class="math inline">\(\sum\limits_{j=l_{i}}^{r_{i}}a_{i}=\sum\limits_{j=l_{i}}^{r_{i}}b_{i}\)</span>
的区间, 把 <span class="math inline">\(b\)</span> 的这部分换到 <span
class="math inline">\(a\)</span> 上, 问能否通过若干次操作将 <span
class="math inline">\(a\)</span> 换成 <span
class="math inline">\(b\)</span>。</p>
<p>思路：</p>
<p>先是套路部分的题意转换, 区间相等<span
class="math inline">\(\implies\)</span>做前缀和. 令 <span
class="math inline">\(c_{i}=a_{i}-b_{i}\)</span> , <span
class="math inline">\(pre_{i}=pre_{i-1}+c_{i}\)</span> ,
题意转化为当某个 <span
class="math inline">\(pre_{l_{i}-1}=pre_{r_{i}}\)</span> 时将 <span
class="math inline">\([pre_{l_{i}},pre_{r_{i}}]\)</span>全部赋为 <span
class="math inline">\(pre_{l_{i}-1}\)</span>(因为此时<span
class="math inline">\(c_{i}=a_{i}-b_{i}=0\)</span>, 前缀和不再变化),
我们要使得最后 <span class="math inline">\(pre\)</span> 数组清零。</p>
<p>一个 <span class="math inline">\(key\;observation\)</span>
是我们要贪心的选取满足 <span
class="math inline">\(pre_{l_{i}-1}=pre_{r_{i}}=0\)</span>的可操作区间,
注意到这样的操作会使得<span
class="math inline">\([pre_{l_{i}},pre_{r_{i}}]=0\)</span>，
然后我们继续寻找可操作区间。</p>
<p>为什么这样做是对的？我们最终的目标是全部置 <span
class="math inline">\(0\)</span>, 如果一个位置 <span
class="math inline">\(pre_{i}\neq0\)</span>, 要想把这个位置置 <span
class="math inline">\(0\)</span>, 一定存在一个 <span
class="math inline">\([l_{j}, r_{j}]\)</span>包含位置 <span
class="math inline">\(i\)</span> 且 <span
class="math inline">\(pre_{l_{j}-1}=pre_{r_{j}}=0\)</span></p>
<p>流程：</p>
<p>贺的题解代码, 现学现卖用 <span class="math inline">\(set\)</span>
维护尚不能更新的区间</p>
<p><span class="math inline">\(1.\)</span> 读入, 前缀和, 不能用的点 (
<span class="math inline">\(pre_{i}\neq0\)</span> ) 放 <span
class="math inline">\(set\)</span> 里, 能用的点压入 <span
class="math inline">\(queue\)</span>, <span
class="math inline">\(vector\)</span>
存一下每个点作为起点或终点时对应的起点终点。</p>
<p><span class="math inline">\(2.\)</span> <span
class="math inline">\(iterator\;lower\_bound\)</span> 维护一下,
找到可更新的区间就把 <span class="math inline">\(set\)</span>
里区间里的点压进 <span class="math inline">\(queue\)</span> 中， 若最终
<span class="math inline">\(set\)</span> 为空则说明可行。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); M=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) br[i]=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) pre[i]=pre[i<span class="number">-1</span>]+ar[i]-br[i]; <span class="comment">// if pre[l-1]=pre[r], that this sub-segment is &quot;Operate-able&quot;.</span></span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q; set&lt;<span class="type">int</span>&gt; S;</span><br><span class="line">S.<span class="built_in">clear</span>();	</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++)  &#123;</span><br><span class="line">	<span class="keyword">if</span>(pre[i]!=<span class="number">0</span>) S.<span class="built_in">insert</span>(i);</span><br><span class="line">	<span class="keyword">if</span>(pre[i]==<span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="built_in">read</span>(), r=<span class="built_in">read</span>();</span><br><span class="line">	ed[l<span class="number">-1</span>].<span class="built_in">push_back</span>(r); <span class="comment">//starting stores endings</span></span><br><span class="line">	ed[r].<span class="built_in">push_back</span>(l<span class="number">-1</span>); <span class="comment">//ending stores startings</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">	<span class="type">int</span> u=q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;ed[u].<span class="built_in">size</span>();i++) <span class="comment">//for every point, enumerate the startings or endings.</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=ed[u][i];</span><br><span class="line">		<span class="keyword">if</span>(pre[v]) <span class="keyword">continue</span>; <span class="comment">//not accept the condition: pre[]=0;</span></span><br><span class="line">		<span class="type">int</span> l=<span class="built_in">min</span>(u,v), r=<span class="built_in">max</span>(u,v);</span><br><span class="line">		IT it=S.<span class="built_in">lower_bound</span>(l); <span class="comment">//typedef set&lt;int&gt;::iterator IT;</span></span><br><span class="line">		<span class="keyword">while</span>(it!=S.<span class="built_in">end</span>()&amp;&amp;(*it)&lt;=r) &#123;</span><br><span class="line">			<span class="type">int</span> p=*it; pre[p]=<span class="number">0</span>; q.<span class="built_in">push</span>(p);</span><br><span class="line">			IT f=it; it++; S.<span class="built_in">erase</span>(f);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(S.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N;i++) ed[i].<span class="built_in">clear</span>();</span><br></pre></td></tr></table></figure>
<p>注意 <span class="math inline">\(iterator\)</span>
不要原地删除后再跳……</p>
<h2 id="codeforces-round-800-div2-22616"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1694">codeforces round 800 (#Div2)
22/6/16</a></h2>
<p>$(1639, rk574) $</p>
<p>C, D玄学猜结论过题, E 题真是人类智慧好题, 但我不会.</p>
<h3 id="e-div1-c"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1693/problem/C">E (Div1 C)</a></h3>
<p>题意： 给出一个有向图起点为 <span class="math inline">\(1\)</span>,
终点为 <span class="math inline">\(N\)</span>,
每次操作可以删去一条边或者随机选择一条边移动,问最优的操作下从起点移动到终点至多要多少步。</p>
<p>思路：</p>
<p>定义 <span class="math inline">\(dis_{u}\)</span> 为 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(N\)</span> 所需的最小边数, 对于一个 <span
class="math inline">\(u\)</span> 的子节点 <span
class="math inline">\(v_{1}, v_{2},\cdots, v_{m}\)</span> 有 <span
class="math inline">\(dis_{v_{1}}, dis_{v_{2}},\cdots,
dis_{v_{m}}\)</span>, 设 <span
class="math inline">\(dis_{v_{1}},dis_{v_{2}},\cdots,
dis_{v_{m}}\)</span> 升序排列, 保证选到 <span
class="math inline">\(v_{j}\)</span> 或更优就要删掉 <span
class="math inline">\(dis_{v_{j+1}},dis_{v_{j+2}},\cdots,
dis_{v_{m}}\)</span> 这 <span class="math inline">\(m-j\)</span>
条边.<br />
我们反向建图, 可以保证每次更新的节点都是正向图中未被更新的 <span
class="math inline">\(dis\)</span> 最小的, 具体如例图：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/lalqfie6.png#pic_center" /><br />
最短路算法会先跑到 <span class="math inline">\(v1\)</span> , 再到 <span
class="math inline">\(v2\)</span> , 再到 <span
class="math inline">\(v3\)</span> , 我们把边权设为入点 <span
class="math inline">\(u\)</span> 还没走过的子节点数 <span
class="math inline">\(+1\)</span> 跑 <span
class="math inline">\(dijkstra\)</span> 就是最后的答案.<br />
代码( <span class="math inline">\(dijkstra\)</span> 记录 <span
class="math inline">\(in\)</span> 数组)：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dijkstra part......</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=e[i].nxt)&#123;</span><br><span class="line">	<span class="type">int</span> y=e[i].to;</span><br><span class="line">	<span class="keyword">if</span>(dis[y]&gt;dis[x]+in[y])&#123;</span><br><span class="line">		dis[y]=dis[x]+in[y];</span><br><span class="line">		q.<span class="built_in">push</span>((node)&#123;dis[y],y&#125;);	</span><br><span class="line">	&#125;</span><br><span class="line">		in[y]--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="codeforces-round-801-div2-22618"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1695">codeforces round 801 (#Div2)
22/6/18</a></h2>
<p>$(1697, rk1030) $<br />
D 题真是人类智慧好题(下次我怕不是要夸 C 题了), 但我还是不会</p>
<p>想 rush 出 D 的 easy version, 失败了, 上小分</p>
<p>这次ABC做得都不顺, 属于真实水平暴露了</p>
<h3 id="d1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1695/problem/D1">D1</a></h3>
<p>题意：<br />
无根树上一个隐藏的顶点 <span class="math inline">\(x\)</span> ,
每次问询你可以知道被问询点与隐藏点 <span
class="math inline">\(x\)</span> 在树上的距离, 给你树的结构,
让你找出最小的问询次数 <span class="math inline">\(k\)</span>
使得一定存在一系列问询点 <span class="math inline">\(v_{1}, v_{2}, ... ,
v_{k}\)</span> 能寻找到 <span class="math inline">\(x\)</span> 点.<br />
<strong>树上节点数量小于2000</strong><br />
思路：<br />
没有思路, 题解是贺的.<br />
<span class="math inline">\(key\;observation:\)</span>
对于任意一个根节点 <span class="math inline">\(u\)</span> ,
其所有子树中, 只能有一颗子树不含查询点,
否则不含查询点的子树的高度相等的点无法排除，只剩一颗子树不含查询点则可以通过容斥确认
<span class="math inline">\(x\)</span> 点所在子树。<br />
考虑 <span class="math inline">\(O(n^2)\)</span> 暴力树型 <span
class="math inline">\(DP\)</span> , 枚举每个根节点并保证选取,
接下来要做的就是确定唯一的子树节点。状态转移 <span
class="math inline">\(dp_{u}=\sum\limits_{v\in
son_{u}}dp_{v}+max(cnt_{u}-1,0)\)</span> , 其中 <span
class="math inline">\(cnt_{u}\)</span> 代表子树个数为 1 的 <span
class="math inline">\(u\)</span> 的子节点数量, 最终答案 <span
class="math inline">\(dp_{root}+1\)</span> , <span
class="math inline">\(dp_{root}\)</span> 记得取 <span
class="math inline">\(min\)</span> , 答案最后再取根节点 <span
class="math inline">\(+1\)</span> 。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1695/submission/163161955">link</a></p>
<h3 id="d2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1695/problem/D2">D2</a></h3>
<p>题意同上。<br />
<strong>树上节点数量小于2e5</strong><br />
思路：<br />
做完 <span class="math inline">\(D1\)</span> 再来看, 一眼 <a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/178wlw2w">换根DP</a> ,
但其实有更优雅的解法(毕竟我也不会换根DP)。</p>
<p>考虑到枚举根节点复杂度过大, 尝试压缩，有两个结论：</p>
<p>1、除了根是否要询问，其余询问的总次数固定。</p>
<p>2、若根节点的的子节点数量 <span class="math inline">\(&gt;2\)</span>
， 则这个根节点不需要询问。</p>
<p>这两个观察是“信仰之跃”式的思维跳跃, 关键是注意到 D1
的子树上查询点的选择其实等价于对于每个以 <span
class="math inline">\(v\)</span> 为根的子树, 要么查找到 <span
class="math inline">\(v\)</span> 节点, 要么在 <span
class="math inline">\(v\)</span> 节点的子树外有查询以确定 <span
class="math inline">\(x\)</span> 点所在的子树, 当根节点的的子节点数量
<span class="math inline">\(&gt;2\)</span> 时几个节点互相确定,
不用选根节点, 性质二又能推出性质一(换根)。</p>
<p>如果没有根节点的子节点的数量 <span
class="math inline">\(&gt;2\)</span> 原树则为一条链, 答案为 1。</p>
<p>抄完题解还是较难理解……<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1695/submission/163211404">link</a></p>
<h2 id="educational-codeforces-round-131-div2-2278"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701">Educational codeforces round
131 (#Div2) 22/7/8</a></h2>
<p>$(1715, rk2820) $<br />
需要复健，怕是废了。 <span class="math inline">\(ABC\)</span>
都做得很慢, 还发现简单套路题做得真的不多, 慢慢刷吧……</p>
<h3 id="d-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701/problem/D">D</a></h3>
<p>题意：由排列 <span class="math inline">\(a\)</span> 构造出数组 <span
class="math inline">\(b\)</span> , 其中 <span
class="math inline">\(b_{i}= \lfloor\frac{i}{a_{i}}\rfloor\)</span>
,现在已知 <span class="math inline">\(b\)</span> , 求一个可行的 <span
class="math inline">\(a\)</span> .<br />
思路：<br />
1、要确定每一个 <span class="math inline">\(b_{i}\)</span> 对应的 <span
class="math inline">\(a_{i}\)</span> 的范围, 我自己用数论分块 + 二分弄出
<span class="math inline">\(a_{i}\)</span> 的范围,
大佬题解的搞法是找等价条件， 注意<del>不</del>到 <span
class="math inline">\(b_{i}= \lfloor\frac{i}{a_{i}}\rfloor\)</span>
等价于： <span
class="math display">\[b_{i}\leq\frac{i}{a_{i}}&lt;b_{i}+1\]</span><br />
又等价于： <span class="math display">\[
\lfloor\frac{i}{b_{i}+1}\rfloor+1 \leq a_{i}
\leq\lfloor\frac{i}{b_{i}}\rfloor\]</span><br />
注意这里的左界的符号变化。<br />
2、此时问题转换为区间选数构成排列，现场我就寄在这里……<br />
简单贪心一下：从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(N\)</span> ,每次加入这个左端点对应的所有区间,
选择右端点最小的先处理, 这样可以给后来的多一点选择空间。<br />
实现：<br />
对每一个左端点建一个 <span class="math inline">\(vector\)</span> , 存
<span class="math inline">\(pair\)</span>, 第一键值右端点,
第二键值存下标 , 再建一个 <span class="math inline">\(pair\)</span> 的
<span class="math inline">\(set\)</span>, 循环时把对应 <span
class="math inline">\(vector\)</span> 全压进 <span
class="math inline">\(set\)</span> 里, <span
class="math inline">\(set\)</span> 每次处理一个。<br />
代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) v[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) &#123;</span><br><span class="line">	<span class="type">int</span> l, r;</span><br><span class="line">	b[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(b[i]==<span class="number">0</span>) l=i+<span class="number">1</span>, r=N;</span><br><span class="line">	<span class="keyword">else</span> l=i/(b[i]+<span class="number">1</span>)+<span class="number">1</span>, r=i/b[i];</span><br><span class="line">	v[l].<span class="built_in">push_back</span>(&#123;r,i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x:v[i]) s.<span class="built_in">insert</span>(x); <span class="comment">//that&#x27;s really useful</span></span><br><span class="line">	PII it=*s.<span class="built_in">begin</span>();</span><br><span class="line">	ar[it.second]=i;</span><br><span class="line">	s.<span class="built_in">erase</span>(it);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) cout &lt;&lt; ar[i] &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>注意： 不要在函数内定义你该死的 vector[MAXN].</p>
<h3 id="e-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701/problem/E">E</a></h3>
<p>开始赛后补题……<br />
题意：给你两个字符串 <span class="math inline">\(s, t\)</span>，长度为
<span class="math inline">\(N, M\)</span> , 均小于 5000, 保证 <span
class="math inline">\(N\geq M\)</span> , 问至少多少个操作能将 <span
class="math inline">\(s\)</span> 转换为 <span
class="math inline">\(t\)</span> , 不能则输出 <span
class="math inline">\(-1\)</span> , 一开始有一个光标在 <span
class="math inline">\(s\)</span> 末尾, 操作有五种：前移一位光标;
后移一位光标; 光标置于最前; 光标置于最后; 删除光标前的字母。<br />
思路：很明显光标肯定只会回到最前端一次或不回去, 不会反复横跳,
并可能在中间存在不需修改的部分。<br />
我们可以把 <span class="math inline">\(s\)</span> 串分为三部分 DP ,
前修改串, 中保留串(不修改), 后修改串。<del>然后开始贺题解：</del> 设
<span class="math inline">\(f_{i,j,0/1/2}\)</span> 表示处理到 <span
class="math inline">\(s\)</span> 的第 <span
class="math inline">\(i\)</span> 个字母, 并已经和 <span
class="math inline">\(t\)</span> 的前 <span
class="math inline">\(j\)</span> 个字母匹配完成, 0/1/2 分别代表 前/中/后
三部分。<br />
1、在任意时刻前缀与后缀部分都可以删除后/前字母,
其中删除后字母的代价为两次操作(右移+删除),
而删除前字母的代价为一次操作(删除), 转移如下：<br />
<span
class="math display">\[f_{i,j,0}=min(f_{i,j,0},f_{i-1,j,0}+2)\]</span><br />
<span
class="math display">\[f_{i,j,2}=min(f_{i,j,2},f_{i-1,j,2}+1)\]</span><br />
2、在 <span class="math inline">\(s_{i}=t_{j}\)</span> 时刻,
可仅仅移动光标完成匹配, 中间部分则直接沿用：<br />
<span
class="math display">\[f_{i,j,0}=min(f_{i,j,0},f_{i-1,j-1,0}+1)\]</span>
<span
class="math display">\[f_{i,j,1}=min(f_{i,j,1},f_{i-1,j-1,1})\]</span>
<span
class="math display">\[f_{i,j,2}=min(f_{i,j,2},f_{i-1,j-1,2}+1)\]</span><br />
3、任意时刻的匹配都能从处于前面的部分转入处于后面的部分：<br />
<span
class="math display">\[f_{i,j,2}=min(\{f_{i,j,0},f_{i,j,1},f_{i,j,2}\})\]</span>
<span
class="math display">\[f_{i,j,1}=min(f_{i,j,0},f_{i,j,1})\]</span><br />
你可以理解为虽然真实顺序是从后到前跳转, 但我们从前到后正常处理匹配,
最终汇总到 <span class="math inline">\(f_{i,j,2}\)</span> 中,
这个记得最后更新<br />
4、若存在不回到开头的方案, 其操作数为 <span
class="math inline">\(N-len\)</span> , 其中 <span
class="math inline">\(len\)</span> 为 <span
class="math inline">\(s,t\)</span> 串最长公共前缀的长度,
它要在与回到开头的答案 <span
class="math inline">\((f_{N,M,2}+1)\)</span> 取 <span
class="math inline">\(min\)</span> 。 代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701/submission/164452698#">link</a><br />
原题卡空间, 还要开滚动数组, 在循环中再设初始值吧……</p>
<h3 id="f"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701/problem/F">F</a></h3>
<p>题意：<br />
数轴上三元组 <span class="math inline">\((i,j,k)\)</span> , 满足 <span
class="math inline">\(i&lt;j&lt;k\;\&amp;\&amp;\;k-i\leq D\)</span>
的为好三元组, 一开始数轴为空, <span class="math inline">\(D\)</span>
为定值, <span class="math inline">\(Q\)</span> 个操作, 每次给你一个数
<span class="math inline">\(\in [1,2e5]\)</span> , 若未加入过就加入,
已加入过就删除, 在线求当前数轴中好三元组的数量。</p>
<p>思路：<br />
简化问题, 考虑加入一个点时它分别作为三元组的 <span
class="math inline">\(i,j,k\)</span> 时的贡献。每个点 <span
class="math inline">\(x\)</span> 的加入会影响 <span
class="math inline">\([max(0,x-D),min(2e5,x+D)]\)</span> 的范围,
我们对每个点 <span class="math inline">\(p\)</span>
<strong>受到</strong>来自左边或右边的影响单独计数, 为 <span
class="math inline">\(l_{p},r_{p}\)</span> , 这样当 <span
class="math inline">\(p\)</span> 作为 <span
class="math inline">\(i\)</span> 时的贡献为 <span
class="math inline">\(\frac{1}{2}*r_{p}*(r_{p}-1)\)</span> , 同理 <span
class="math inline">\(p\)</span> 作为 <span
class="math inline">\(k\)</span> 时的贡献为 <span
class="math inline">\(\frac{1}{2}*l_{p}*(l_{p}-1)\)</span> 。</p>
<p>现在考虑当 <span class="math inline">\(p\)</span>
处于三元组中间时的贡献, 看上去难以下手(我到这儿就想不出来了),
一个切入口是暴力统计<br />
<span
class="math display">\[\sum\limits_{i=p-D}^{p-1}{[i_{exist}]}*\sum\limits_{k=p+1}^{i+D}{[k_{exist}]}\]</span><br />
(<span class="math inline">\(i_{exist}\)</span>表示 <span
class="math inline">\(i\)</span> 点已经在数轴上)这个暴力重复过多,
可以再拆一下贡献, <span
class="math inline">\(\sum\limits_{k=p+1}^{i+D}{[k_{exist}]}\)</span>
就可以拆为<br />
<span
class="math display">\[\sum\limits_{k=1}^{i+D}{[k_{exist}]}-\sum\limits_{k=1}^{p}{[k_{exist}]}\]</span><br />
来做一个简单前缀和, 记 <span class="math inline">\(c[l,r]\)</span> 为
<span class="math inline">\([l,r]\)</span> 内点的个数,
所以贡献为：<br />
<span
class="math display">\[\sum\limits_{i=p-D}^{p-1}{([i_{exist}]*c[1,i+D])}-c[p-D,p-1]*c[1,p]\]</span><br />
前面是动态的所以还是得展开, 我们可以再记 <span
class="math inline">\(v_{i}=c[1,i+D]\)</span> , 最终贡献：<br />
<span
class="math display">\[\sum\limits_{i=p-D}^{p-1}{([i_{exist}]*v_{i})}-c[p-D,p-1]*c[1,p]\]</span><br />
剩下的简单了, 线段树维护 <span class="math inline">\(v, c\)</span> 就行,
之前的 <span class="math inline">\(l_{p}, r_{p}\)</span> 也可以用 <span
class="math inline">\(c[x-D,x-1],c[x+1,x+D]\)</span> 换掉了, 注意有关
<span class="math inline">\(0\)</span>
的边界情况还是要特判的……删除同理……<br />
代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1701/submission/164682417">link</a><br />
其实小细节挺多, 我的实现略繁琐， 用了 <span class="math inline">\(v1,
v2\)</span> 两个数组来处理 <span
class="math inline">\([i_{exist}]\)</span> , <span
class="math inline">\(v1\)</span> 为 <span
class="math inline">\(v\)</span> , <span
class="math inline">\(v\)</span> 有两次更新, 在单点更新 <span
class="math inline">\(c\)</span> 时把之前 <span
class="math inline">\(v1\)</span> 积累的更新给 <span
class="math inline">\(v2\)</span>
一并加上，向上更新；第二次区间更新考虑单点更新 <span
class="math inline">\(c\)</span> 时对 <span
class="math inline">\([max(1,i-d),2e5]\)</span> 的 <span
class="math inline">\(v1,v2\)</span> 都有影响, 向下更新, 打懒标记什么的,
最后实际询问的是 <span class="math inline">\(v2\)</span>
贡献。删除的更新顺序与上面相反。此外还要注意数轴长度固定为 <span
class="math inline">\(200000\)</span>，与 <span
class="math inline">\(Q,D\)</span> 无关, 记得开 <span
class="math inline">\(long\;long\)</span> ,
这题算一个不错的线段树题。</p>
<h2 id="codeforces-round-808-div2-22716"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708">codeforces round 808 (#Div2)
22/7/16</a></h2>
<p><span class="math inline">\((1661\rightarrow1621,
rk2785)\)</span><br />
两个月来最差的一把。<br />
十九分钟过了<span class="math inline">\(A,B\)</span> ,
然后罚坐到比赛结束都没能把1600的 <span class="math inline">\(C\)</span>
写出来, 明明只是一个贪心, 现在是7/21的凌晨1：48, 喝了咖啡睡不着,
起来补题, 最近效率很低, 作息也不稳定,
今天能补到哪里算哪吧……现在学OI只有一个目标……cf上1900,
人生的意义就是这点薯条了, 其他我都不想管……</p>
<h3 id="c"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/problem/C">C</a></h3>
<p>题意：<br />
对于数组 <span class="math inline">\(a\)</span> 与初始值 <span
class="math inline">\(q\)</span>, 按顺序遍历 <span
class="math inline">\(a_{1}\)</span> 到 <span
class="math inline">\(a_{n}\)</span> ,若 <span class="math inline">\(q
\geq a_{i}\)</span> , 则可以取走 <span
class="math inline">\(a_{i}\)</span> 而不付代价, 否则若选择取走 <span
class="math inline">\(a_{i}\)</span> 则会付出 1 的代价,
问最多能取走几个物品。</p>
<p>思路：<br />
越晚取越好是肯定的, 但太晚取多余的 <span
class="math inline">\(q\)</span> 又会被浪费。<br />
可以推断出不取 <span class="math inline">\(a_{i}\)</span> 的条件：<span
class="math inline">\(q&lt;a_{i}\)</span> 且 <span
class="math inline">\(q&lt;\sum\limits_{i}^{N}[q&lt;a_{i}]\)</span>,
这样保证即使现在不花 <span class="math inline">\(q\)</span> 来取,
后面总是能花掉的。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/submission/165042972">link</a></p>
<p>这题二分也行, 搞笑的是我考场上两个都想过却都认为自己想假了,
试都没试一下。</p>
<h3 id="d-2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/problem/D">D</a></h3>
<p>题意：<br />
求一个 <span class="math inline">\(N\)</span> 位有序数组(每项值域为
<span class="math inline">\([1,5e5]\)</span> , 从小到大排序)的 <span
class="math inline">\(N-1\)</span> 阶差分数组(最后的一个数字),
不同的是每次求完差分数组都要对其从小到大排序。<br />
思路：<br />
以为是推式子题, 啥也没推出来。 很有趣的一道题,
看到差分数组想到痛苦的回忆, 再看一眼题解 "对于值域为 <span
class="math inline">\(N\)</span> 的有序数组差分后最多产生 <span
class="math inline">\(\sqrt{N}\)</span> 个不同的数" , 逐渐痛苦起来了,
又注意到 <span class="math inline">\(0\)</span> 对差分无贡献,
这样本题就暴力可解了, 复杂度 <span
class="math inline">\(O(N\sqrt{N})\)</span>。<br />
代码： 上 <span class="math inline">\(map\)</span> 和 <span
class="math inline">\(auto\)</span><br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); mp.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>(), mp[ar[i]]++;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;N;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(it-&gt;second&gt;<span class="number">1</span>) mp2[<span class="number">0</span>]+=(it-&gt;second<span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">auto</span> nxt=it; nxt++;</span><br><span class="line">		<span class="keyword">if</span>(nxt!=mp.<span class="built_in">end</span>()) mp2[nxt-&gt;first - it-&gt;first]++;</span><br><span class="line">	&#125;</span><br><span class="line">	mp=mp2; mp2.<span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; mp.<span class="built_in">begin</span>()-&gt;first &lt;&lt; endl;</span><br></pre></td></tr></table></figure> 注意调用说明存在, 因此 <span
class="math inline">\(mp2[0]\)</span> 仅仅会在 it-&gt;second 大于 1
时被调用, 不能写成 max(0,it-&gt;second-1) 的形式。<br />
这题在 codechef 上有一个<a
target="_blank" rel="noopener" href="https://www.codechef.com/START33B/problems/ARRAY_OPS">困难版本</a>,
应该只能用 <span class="math inline">\(n log n\)</span> 做法了, 给个<a
target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/542633422">link</a>自己看……</p>
<h3 id="e-2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/problem/E">E</a></h3>
<p>题意：<br />
给你错误的求最小生成树的 <span class="math inline">\(Prim\)</span>
代码(贪心部分只寻找了当前点连接的最小边, 生成从每个点出发的 DFS 搜索树),
给你图, 保证有唯一正确的最小生成树,
问从每个节点运行错误代码得到的是不是最小生成树。<br />
思路：<br />
先把正确的最小生成树求出来, 观察图像：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/z72rtloo.png" /><br />
随手做的……红线为 MST 边, 在这个例子中, 从 1, 2, 8
节点开始的错误算法会选择 4-5 边导致最后生成错误的树。<br />
我们设没选的边类型分为两种, 返祖边与横叉边。让我们从 8 号节点开始举例,
按照错误的算法, 先连 8-1, 再连 1-2, 此时 2-8 为一条返祖边, 连接选择过的
8 号节点, 所以返祖边不会被选择。继续模拟, 连 2-5, 此时按照错误算法应连接
5-4，5-4 便为一条横叉边, 其两个端点位于 2 号节点的不同子树中, 因为 4
号节点未被选择过, 按照 DFS 的顺序, 正确的 2-4 边不可能被选择, 要么选 5-4
边, 要么选择另一条(如果存在) x-4 的横叉边, 所以横叉边不能存在。<br />
问题转化为计算以每个点为根时是否存在横叉边, 考虑每条非 MST 上的边 u-v,
若 lca(u,v)!=u/v, 则 u, v 子树外的点全部不合法(先到 u/v, 再根据 DFS 走
u-v 边), 若 lca(u,v)=u/v, 则从 u 到 v 链上的点的子树全部不合法(除u,
v两点), 如图：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/w8s2i1ma.png" /><br />
从 3 号节点开始走不合法。<br />
最后用树上差分的方式给不合法部分打上标记, 统计输出。<br />
具体讲一下这里的差分策略, 对于 lca!=u/v 情况, 在 u, v, lca 上打上 +1,
+1, -1 标记; 对于 lca=u/v 情况, 在 <span
class="math inline">\(u\;(dep_{u} \geq dep_{v})\)</span> 上及满足 <span
class="math inline">\(fa[t][0]=v\)</span> 的 t 点上打上 +1, -1 标记,
最后 dfs 统计的时候每个点的值等于该点到根节点链上的差分值之和, 若值为 0
则说明该点合法。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1708/submission/166497847">link</a><br />
事实上我可以边读边边跑 <span class="math inline">\(kruskal\)</span>
的……就不用 <span class="math inline">\(f1\)</span>, <span
class="math inline">\(f2\)</span> 了。</p>
<h2 id="codeforces-round-809-div2-22718"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1706">codeforces round 809 (#Div2)
22/7/18</a></h2>
<p><span class="math inline">\((1621\rightarrow1694,
rk733)\)</span><br />
D1 糊过的, 现在自己代码看不懂了......</p>
<h3 id="d2-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/D2">D2</a></h3>
<p>题意：<br />
给定数组 <span class="math inline">\(a\)</span> , 长度为 <span
class="math inline">\(N\)</span>, 定义 <span
class="math inline">\(a\)</span> 的价值为 <span
class="math display">\[\underset{1\leq i \leq
N}{max}(\lfloor\frac{a_{i}}{p_{i}}\rfloor)-\underset{1\leq i \leq
N}{min}(\lfloor\frac{a_{i}}{p_{i}}\rfloor)\]</span> 其中 <span
class="math inline">\(1 \leq p_{i} \leq k\)</span> , 给定 <span
class="math inline">\(k\)</span> , 求最小的价值, <span
class="math inline">\(1 \leq N, a_{i}, k \leq 1e5\)</span>, 空间 <span
class="math inline">\(64M\)</span> 。<br />
思路：<br />
有一点整除分块思想。<br />
D1还可以简单枚举 <span class="math inline">\(\lfloor
\frac{a_{i}}{p_{i}}\rfloor\)</span> , 但现在不行了, 算一下当 <span
class="math inline">\(k\)</span> 足够大时, 设 <span
class="math inline">\(b_{i}=\lfloor \frac{a_{i}}{p_{i}}\rfloor\)</span>
最多有 <span class="math inline">\(2 \sqrt a_{i}-1\)</span> 种取值,
<span class="math inline">\(b_{i}\)</span> 不可能全部存下来,
尝试在双指针扫的同时动态求 <span class="math inline">\(b_{i}\)</span>,
用 <span class="math inline">\(cnt_{i}\)</span> 表示区间内一个 <span
class="math inline">\(i(a_{i})\)</span> 对应的合法的 <span
class="math inline">\(b_{i}\)</span> 数量, 当 <span
class="math inline">\(tot=\sum[cnt_{i}\geq 1]=N\)</span>
时更新最小区间长度。 在具体实现上, 由于 <span
class="math inline">\(p_{i}\)</span> 从小到大, <span
class="math inline">\(b_{i}\)</span> 从大到小, 从可能的最大值开始双指针,
分开给左右指针开 <span class="math inline">\(vector\)</span> ,
处理一个位置后清空它的内存。<br />
代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); K=<span class="built_in">read</span>(); M=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>(), cnt[i]=<span class="number">0</span>, M=<span class="built_in">max</span>(M,ar[i]);</span><br><span class="line">N=<span class="built_in">unique</span>(ar+<span class="number">1</span>,ar+<span class="number">1</span>+N)-ar<span class="number">-1</span>; <span class="comment">//去重</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=M;i++)</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(qr[i]);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	pl[i]=<span class="number">1</span>; ql[ar[i]].<span class="built_in">push_back</span>(i); <span class="comment">//在对应的值上挂上 i , 这里初始 ai/1 = ai, 在 ai 上挂 i, 后面也好分辨 </span></span><br><span class="line">	pr[i]=<span class="number">1</span>; qr[ar[i]].<span class="built_in">push_back</span>(i); <span class="comment">//右端点同理 </span></span><br><span class="line">&#125;</span><br><span class="line">tot=<span class="number">0</span>; ans=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> r=M,l=M;l&gt;=<span class="number">0</span>;l--)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> i=ql[l].<span class="built_in">begin</span>();i!=ql[l].<span class="built_in">end</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!cnt[*i]++) tot++; <span class="comment">//cnt, tot一起加, 注意顺序</span></span><br><span class="line">		pl[*i]=ar[*i]/(ar[*i]/pl[*i])+<span class="number">1</span>; <span class="comment">//根据整除分块, 去往下一段的左端点注意 +1</span></span><br><span class="line">		<span class="keyword">if</span>(pl[*i]&lt;=<span class="built_in">min</span>(ar[*i],K)) ql[ar[*i]/pl[*i]].<span class="built_in">push_back</span>(*i); <span class="comment">//为甚么 pl[i] &lt;= ar[i], 因为 ar[i]/(ar[i]/pl[i]) 需要定义 ? </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(ql[l]); <span class="comment">//处理完了满足 ai/pi=l 的几个端点</span></span><br><span class="line">	<span class="keyword">while</span>(tot==N &amp;&amp; r&gt;=l) &#123;<span class="comment">//若出现满足条件的区间, 尝试缩小它</span></span><br><span class="line">		ans=<span class="built_in">min</span>(r-l,ans);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i=qr[r].<span class="built_in">begin</span>();i!=qr[r].<span class="built_in">end</span>();i++)&#123; <span class="comment">//考虑右端点同理 </span></span><br><span class="line">			<span class="keyword">if</span>(!--cnt[*i]) tot--;</span><br><span class="line">			pr[*i]=ar[*i]/(ar[*i]/pr[*i])+<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span>(pr[*i]&lt;=<span class="built_in">min</span>(ar[*i],K)) qr[ar[*i]/pr[*i]].<span class="built_in">push_back</span>(*i);		</span><br><span class="line">		&#125;	</span><br><span class="line">		<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(qr[r--]); <span class="comment">//先清空, 再缩 </span></span><br><span class="line">	&#125;  		</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; endl; </span><br></pre></td></tr></table></figure>
<p>有一些要注意的点：<br />
1、在这里 <span class="math inline">\(p_{i} \leq a_{i}\)</span> ,
因为我们不需要 <span class="math inline">\(p_{i} &gt; a_{i}\)</span> 时
<span class="math inline">\(b_{i}=0\)</span> 的情况,
这样会在整除分块时越界, 而且所有 <span
class="math inline">\(b_{i}=0\)</span> 的情况都可以用 <span
class="math inline">\(b_{i}=1\)</span> 替代。</p>
<p>2、循环改成 $ for(auto i:ql[l])$ 会简单不少……现在只是让你看一下挂
<span class="math inline">\(i\)</span> 的好处。</p>
<p>3、<span class="math inline">\(vector\)</span> 释放内存用
vector<T>().swap(xxx), 开头的释放不可避免, 因为右指针没有缩到底。</p>
<h3 id="e-3"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/problem/E">E</a></h3>
<p>题意：<br />
无向图,给 <span class="math inline">\(n\)</span> 个点, <span
class="math inline">\(m\)</span> 条边并标号, <span
class="math inline">\(q\)</span> 个询问, 每次询问一个最小的 <span
class="math inline">\(k\)</span> , 满足标号在 <span
class="math inline">\([l,r]\)</span> 之间的点仅使用前 <span
class="math inline">\(k\)</span> 条边便两两联通, <span
class="math inline">\(n \leq 1e5, \;m, q \leq 2e5\)</span>。<br />
思路：<br />
看到 <span class="math inline">\(q \leq 2e5\)</span> ,思考可复用性,
考虑到记 <span class="math inline">\(c_{i}\)</span> 为 <span
class="math inline">\(i\)</span> 点到 <span
class="math inline">\(i+1\)</span> 点经过的边的最大编号, 建线段树,
每次静态查询 <span class="math inline">\(c_{l}\)</span> 到 <span
class="math inline">\(c_{r}\)</span> 之间的最大值, 问题转化为求出 <span
class="math inline">\(c_{i}\)</span>。<br />
如果你知道 <span class="math inline">\(kruskal\)</span>重构树,
那么你赢麻了,因为你知道：<br />
原图中两个点之间的所有简单路径上最大边权的最小值 =
最小生成树上两个点之间的简单路径上的最大值 = <span
class="math inline">\(Kruskal\)</span>重构树上两点之间的 LCA
的权值。<br />
但我输麻了, 我只会最小生成树, 所以我证明一下结论的前半部分：<br />
按照 <span class="math inline">\(kruskal\)</span> 算法的加边顺序,
如果有一条边 u-v 不在 MST 上,
说明先前的贪心已经使用了边权更小的边连接上了 u-v, 所以结论成立。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1706/submission/166641432">link</a><br />
简单线段树 + LCA + kruskal......</p>
<h2 id="educational-codeforces-round-132-div2-22721"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1709">Educational codeforces round
132 (#Div2) 22/7/21</a></h2>
<p>$(1694, rk3029) $<br />
又寄回来了, 我都不想写这个, 搞得很尴尬, 这场是最寄的, C &gt;&gt; D, 而我
D 又因为一个 max/min 没加写挂了, 就下了大分, 又成为 1600 守门员......
因为博客太长, 后台的高亮显示已经出问题了, 决定每 10 场开一篇博客,
然后总体记录总结。</p>
<h3 id="c-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/C">C</a></h3>
<p>题意：给你括号串, 问号为通配符, 保证存在合法, 问是否唯一。<br />
思路：注意到这是个贪心就好写了, 因为保证存在合法, 可以先把所有的 <span
class="math inline">\((\)</span> 填掉, 再填 <span
class="math inline">\()\)</span>, 除此之外最有可能合法的便是交换最后一个
<span class="math inline">\((\)</span> 与第一个 <span
class="math inline">\()\)</span> , 只要检查一下这个就可以了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/submission/166643105">link</a></p>
<h3 id="e-4"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1709/problem/E">E</a></h3>
<p>D是裸的线段树就不放了……<br />
题意：给一颗树, 顶点有值($ 1a_{i} ^{30}$),
为了满足树上所有简单路径的异或和不为零,
你需要至少修改几个顶点(可改为任意正整数)？顶点数 <span
class="math inline">\(\leq 2e5\)</span>。<br />
思路：<br />
没有思路, 贺题解, 启发式合并。<br />
一开始没有注意到可修改为任意正整数, 想了个寂寞。<br />
注意到如果一条简单路径不合法, 改变 lca 处一定不劣于改变其他处,
因为改变的值可以任意构造, 改变 lca
可以保证切断所有子树对其他部分的影响。这样, 记 <span
class="math inline">\(dis_{i}\)</span> 为 <span
class="math inline">\(i\)</span> 点到根节点的异或和, 所以 <span
class="math inline">\(u\rightarrow v\)</span> 的简单路径和为 $
dis_{u}dis_{v} a_{lca}$ , 根据异或的性质, 对于每个满足 <span
class="math inline">\(x=lca(u,v)\)</span> 的 <span
class="math inline">\(x\)</span> 点, 若 <span
class="math inline">\(dis_{u} \bigoplus dis_{v}=a_{x}\)</span>
则必须要修改 <span class="math inline">\(x\)</span> 点。<br />
具体实现方面：dsu on tree, 每一个节点开一个 <span
class="math inline">\(set\)</span> 记录这个节点子树的(含自身) <span
class="math inline">\(dis\)</span>, 若一个节点被改变, 则其 <span
class="math inline">\(set\)</span> 为空(切断连接), <span
class="math inline">\(dfs\)</span> 一个节点的时候把它的重儿子直接换上来,
对于轻儿子, 先查询再尝试合并。<br />
代码：(省略了求 <span class="math inline">\(dis\)</span> 的过程)<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(son[x]) <span class="built_in">dfs2</span>(son[x],x), <span class="built_in">swap</span>(s[x],s[son[x]]);</span><br><span class="line">	<span class="type">int</span> tag=<span class="number">0</span>; <span class="comment">//choose(delete) or not</span></span><br><span class="line">	<span class="keyword">if</span>(s[x].<span class="built_in">find</span>(dis[x]^ar[x])!=s[x].<span class="built_in">end</span>()) tag=<span class="number">1</span>; <span class="comment">// detect dis[x] illegal to insert</span></span><br><span class="line">	s[x].<span class="built_in">insert</span>(dis[x]); <span class="comment">//insert</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=head[x];i;i=e[i].nxt)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> y=e[i].to;</span><br><span class="line">		<span class="keyword">if</span>(y==f||y==son[x]) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="built_in">dfs2</span>(y,x);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i:s[y]) <span class="keyword">if</span>(s[x].<span class="built_in">find</span>(ar[x]^i)!=s[x].<span class="built_in">end</span>()) tag=<span class="number">1</span>; <span class="comment">//find s[son[x]] ^ s[y] = ar[x] </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> i:s[y]) s[x].<span class="built_in">insert</span>(i); <span class="comment">//combine</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(tag) s[x].<span class="built_in">clear</span>(), ans++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> s.find() 可以找元素, 找不到返回 end() 的迭代器。<br />
再分享一个 <span class="math inline">\(\color{red}{wsyear}\)</span> 的<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/blog/wsyear/solution-cf1709e">代码</a>,
惊为天人的简洁。</p>
<h2 id="codeforces-round-810-div2-22724"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1711">codeforces round 810 (#Div2)
22/7/24</a></h2>
<p><span class="math inline">\((1639\rightarrow1629,
rk1814)\)</span><br />
已经无处可掉了, 手速场没手速, 罚时多 D 又不会……</p>
<h3 id="d-3"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1711/problem/D">D</a></h3>
<p>题意：<br />
下 <span class="math inline">\(N\)</span> 天雨, 每天下雨在数轴上 <span
class="math inline">\(x_{i}\)</span> 处, 强度为 <span
class="math inline">\(p_{i}\)</span>, 位置 <span
class="math inline">\(x_{j}\)</span> 会受到 <span
class="math inline">\(max(0,p_{i}-|x_{i}-x_{j}|)\)</span> 的降雨,
当任意时间任意位置降雨量大于 <span class="math inline">\(M\)</span>
时发生洪水, 问对于每一天, 取消当日降雨量会不会导致洪水。<br />
思路：见等差数列想差分, 下面是一个 <span
class="math inline">\(x_{i}=5\)</span> , <span
class="math inline">\(p_{i}=4\)</span>​ 的二阶差分表格</p>
<table>
<thead>
<tr>
<th style="text-align: center;">0</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">4</th>
<th style="text-align: center;">3</th>
<th style="text-align: center;">2</th>
<th style="text-align: center;">1</th>
<th style="text-align: center;">0</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">-1</td>
<td style="text-align: center;">0</td>
</tr>
<tr>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">-2</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<p>可以做二阶前缀和回到原数组, 现在看去掉一段 <span
class="math inline">\((x_{i},p_{i})\)</span> 的降雨对在总降雨量为 <span
class="math inline">\(val\)</span> 的 <span
class="math inline">\(x_{j}\)</span> 点有什么影响:<br />
1、设 <span class="math inline">\(x_{j}\geq x_{i}\)</span> ,此时 <span
class="math inline">\(x_{j}\)</span> 点降雨量为: <span
class="math display">\[val-(p_{i}-(x_{j}-x_{i})) \iff
val-p_{i}+x_{j}-x_{i}\]</span><br />
所以若不发生洪水需要满足: <span class="math display">\[val+x_{j}-M \leq
p_{i}+x_{i}\]</span> 2、设 <span class="math inline">\(x_{j} &lt;
x_{i}\)</span> , 同理有 <span class="math inline">\(val-M-x_{j} \leq
p_{i}-x_{i}\)</span><br />
接下来我们只需求解最大的 <span
class="math inline">\(val+x_{j}-M\)</span> 与 <span
class="math inline">\(val-M-x_{j}\)</span> 即可。 具体来说, 我们不用关心
<span class="math inline">\(x_{j}\)</span> 和 <span
class="math inline">\(x_{i}\)</span> 的大小关系,
因为原式计算是带绝对值的, 不影响结果。又因为若 <span
class="math inline">\(val \leq M\)</span> , 则当点去掉降雨无影响,
需要省去。<br />
代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1711/submission/167982586">link</a><br />
本题用 <span class="math inline">\(vector\)</span> 就行了,
当然若你用扫描线/差分+线段树写 div2D, 也是可以的……</p>
<h3 id="e-5"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1711/problem/E">E</a></h3>
<p>数位DP, 咕</p>
<h2 id="codeton-round-2-div12-22731"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704">codeTON Round 2 (#Div1+2)
22/7/31</a></h2>
<p><span class="math inline">\((1629\rightarrow1651,
rk2075)\)</span><br />
应该是打的第一场 div1+2，因为 D 的一个构造想不出来罚坐近 2h, 又成了 ABC
战神……</p>
<h3 id="d-4"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/D">D</a></h3>
<p>题意：<br />
给你一个数组 <span class="math inline">\(b\)</span> , 长度为 <span
class="math inline">\(m\)</span> , 在此基础上生成 <span
class="math inline">\(n\)</span> 个数组, <span
class="math inline">\(c_{1}...c_{n}\)</span> , 一开始的 <span
class="math inline">\(c_{i}=b\)</span> , 有一个特殊数组 <span
class="math inline">\(c_{k}\)</span> ; 生成数组的规则是:<br />
1、选择 <span class="math inline">\(i, j\)</span>, 满足 <span
class="math inline">\(2 \leq i &lt; j \leq m-1\)</span> <span
class="math display">\[t \neq k, c_{t}[i-1]+1, c_{t}[i]-1, c_{t}[j]-1,
c_{t}[j+1]+1\]</span> 2、选择 <span class="math inline">\(i, j\)</span>,
满足 <span class="math inline">\(2 \leq i &lt; j \leq m-2\)</span> <span
class="math display">\[t = k, c_{t}[i-1]+1, c_{t}[i]-1, c_{t}[j]-1,
c_{t}[j+2]+1\]</span> 每个 <span class="math inline">\(c_{i}\)</span>
至少完成一次上述操作, 给你最后的 <span
class="math inline">\(c_{1}...c_{n}\)</span> , 问你 <span
class="math inline">\(k\)</span> , 以及 <span
class="math inline">\(c_{k}\)</span> 完成了多少次操作？<br />
思路：<br />
本题看似唬人, 实则唬人, 设 <span class="math inline">\(pre\)</span>
为一个 <span class="math inline">\(c_{i}\)</span> 的前缀和数组：<br />
对于操作一, <span class="math inline">\(pre[i-1]+1,
pre[j]-1\)</span><br />
对于操作二, <span class="math inline">\(pre[i-1]+1, pre[j]-1,
pre[j+1]-1\)</span><br />
于是做完了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/submission/168030149">link</a></p>
<h3 id="e-6"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/E">E</a></h3>
<p>题意：<br />
有向无环图(<span class="math inline">\(n,m\leq1000\)</span>),
每个节点有正值, 恰好有一个没有出边的节点, 每秒钟每个节点的值 -1 ,
并将所通向的节点的值 +1 , 找到所有的节点的值为 0 的第一个时刻, 答案模
998244353 输出。<br />
思路：<br />
类似拓扑排序, 但要注意在节点变为 0 后是有重新获值的可能性的,
比如说本身为 0 , 但几代前的父节点有值, 考虑起来十分复杂, 于是注意到
<span class="math inline">\(n \leq 1000\)</span> , 只要暴力完成前 <span
class="math inline">\(n\)</span> 轮, 再拓扑最后一轮累加,
就可以了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/submission/168075469">link</a></p>
<h3 id="f-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1704/problem/F">F</a></h3>
<p>SG函数, 咕咕<sub>咕咕咕</sub></p>
<h2 id="educational-codeforces-round-133-div2-2284"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1716">Educational codeforces round
133 (#Div2) 22/8/4</a></h2>
<p><span class="math inline">\((1651\rightarrow1749,
rk476)\)</span><br />
坚持不看榜人 70 mins 才出 C, 以为又要寄了, 但这把 CD 都难……, ABC
战神反而能上分……</p>
<h3 id="d-5"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1716/problem/D">D</a></h3>
<p>题意：<br />
给你 <span class="math inline">\(n, k\)</span>, 从数轴原点开始, 第 <span
class="math inline">\(i\)</span> 次可以跳 <span
class="math inline">\((i+k-1)\)</span> 的倍数步(不可以跳 0 步), 问你跳到
<span class="math inline">\([1,n]\)</span> 格各有多少种方案。 <span
class="math inline">\(n,k \leq 2e5\)</span>, 方案数模 998244353。<br />
思路：<br />
完全背包问题稍微改了改, 最多有 <span class="math inline">\(m\)</span>
种物品(步数与其倍数), 满足 <span class="math inline">\((2* k+m-1)* m
\leq 2* n\)</span> (等差数列求和), 注意每种"物品"至少要取一种,
可以从之前的转移……， 复杂度 <span class="math inline">\(O(n\sqrt
n)\)</span>。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;(<span class="number">2</span>*K+i<span class="number">-1</span>)*i&lt;=<span class="number">2</span>*N;i++)&#123;</span><br><span class="line">	<span class="type">int</span> t=i+K<span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=t;j&lt;=N;j++)</span><br><span class="line">		f[j]=(f[j]+f[j-t])%p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=N;j&gt;=t;j--) f[j]=f[j-t];</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=t<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--) f[j]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=t;j&lt;=N;j++) ans[j]=(ans[j]+f[j])%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure> 好像不难啊……上赛场就摆烂……</p>
<h3 id="e-7"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1716/problem/E">E</a></h3>
<p>题意：<br />
给你 <span class="math inline">\(2^n\)</span> 长的数组 <span
class="math inline">\(a\)</span> , <span
class="math inline">\(q\)</span> 组操作, 每次操作给一个 <span
class="math inline">\(k\)</span> , 数组从 <span
class="math inline">\(1\)</span> 遍历到 <span
class="math inline">\(2^n-2^k\)</span> , 在没有交换过的前提下交换 <span
class="math inline">\(a_{i}\)</span> 与 <span
class="math inline">\(a_{i+2^k}\)</span> ,
每次操作结束后问你最大字串和(包括空字串)。 <span class="math inline">\(n
\leq 18, q \leq 2e5\)</span>。<br />
思路：<br />
  手玩一组样例, 设 <span class="math inline">\(k=1\)</span> , <span
class="math inline">\(a_{1}\)</span> 换 <span
class="math inline">\(a_{3}\)</span>, <span
class="math inline">\(a_{2}\)</span> 换 <span
class="math inline">\(a_{4}\)</span>, <span
class="math inline">\(a_{5}\)</span> 换 <span
class="math inline">\(a_{7}\)</span>, <span
class="math inline">\(a_{6}\)</span> 换 <span
class="math inline">\(a_{8}\dots\)</span>。
我们想到了要找寻一种性质来总体描绘一次操作中的所有交换。因为一次操作内部以
<span class="math inline">\(2^k\)</span> 为单位, 想到下标的二进制表示,
若下标从 <span class="math inline">\(0\)</span> 开始, <span
class="math inline">\(0, 1, 10, 11, 100, 101, 110, 111\)</span> ,
不难看出每次交换其实是让下标异或 <span
class="math inline">\(2k\)</span>。<br />
  如何维护最大字串和？ 考虑线段树, <span
class="math inline">\(2^n\)</span> 的长度, 一定是漂亮的满二叉树,
每次给的 <span class="math inline">\(k\)</span> 相当于在线段树的倒数
<span class="math inline">\(k+1\)</span>
层交换两个子树。若暴力做这个交换, 每次自底向上维护, 则有 <span
class="math inline">\(O(4^n)\)</span> 的复杂度, 肯定是寄的。<br />
  题解的方法优雅又暴力, 把节点的所有版本在建树时就保存下来,
最后操作的时候直接异或输出异或输出就可以了。 对于一个长度为 <span
class="math inline">\(2^m\)</span> 的线段树节点 <span
class="math inline">\(v\)</span> , 有 <span
class="math inline">\(2^m\)</span> 种状态, 对应当前 <span
class="math inline">\(\sum2^k=[1,2^m]\)</span> , 其左右儿子同理便有
<span class="math inline">\(2^{m-1}\)</span> 种状态, 我们从 <span
class="math inline">\(0\)</span> 到 <span
class="math inline">\(2^m-1\)</span> 枚举 <span
class="math inline">\(i\)</span> ( <span
class="math inline">\(0\)</span> 为初始态, <span
class="math inline">\(2^{m}-1\)</span> 为 <span
class="math inline">\(k\)</span> 取遍 <span
class="math inline">\(0,1,2,\dots, m-1\)</span> 的“最乱状态”),
有如下转移(设 <span class="math inline">\(t(v,x)\)</span> 为 <span
class="math inline">\(v\)</span> 节点的第 <span
class="math inline">\(x\)</span> 种状态)：<br />
1、 <span class="math inline">\(i &lt; 2^{m-1},
\;t(v,i)=combine(\;t(ln,i),\;t(rn,i)\;)\)</span><br />
2、 <span class="math inline">\(i \geq 2^{m-1},
\;t(v,i)=combine(\;t(rn,i-(2^{m-1})),
\;t(ln,i-(2^{m-1}))\;)\)</span><br />
这个 <span class="math inline">\(combine\)</span> 就写成结构体构造函数,
维护一些最大前缀和, 后缀和, 字串和, 总值这样的东西……<br />
因为 <span class="math inline">\(i \in [0,2^{m}-1]\)</span> , 所以 <span
class="math inline">\(i \geq 2^{m-1}\)</span> 就代表出现了 <span
class="math inline">\(k=m-1\)</span> 换掉了 <span
class="math inline">\(v\)</span> 的左右儿子。<br />
这种做法复杂度全在建版本上, 版本有 <span
class="math inline">\(n2^n\)</span> 个, 查询为 <span
class="math inline">\(O(1)\)</span> , 复杂度为 <span
class="math inline">\(O(n2^n)\)</span> .<br />
代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">	<span class="type">int</span> v, pre, suf, mx;</span><br><span class="line">	<span class="built_in">node</span>(node a, node b)&#123;</span><br><span class="line">		v=a.v+b.v;</span><br><span class="line">		pre=<span class="built_in">max</span>(a.pre,a.v+b.pre);</span><br><span class="line">		suf=<span class="built_in">max</span>(b.suf,a.suf+b.v);</span><br><span class="line">		mx=<span class="built_in">max</span>(<span class="built_in">max</span>(a.mx,b.mx),a.suf+b.pre);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">node</span>(<span class="type">int</span> x)&#123; v=x; pre=suf=mx=<span class="built_in">max</span>(<span class="built_in">ll</span>(<span class="number">0</span>),x); &#125;</span><br><span class="line">	<span class="built_in">node</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;node&gt; t[<span class="number">4</span>*MX];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bt</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> e)</span></span>&#123;</span><br><span class="line">	t[n].<span class="built_in">resize</span>(e-s+<span class="number">3</span>);</span><br><span class="line">	<span class="keyword">if</span>(s==e) t[n][<span class="number">0</span>]=<span class="built_in">node</span>(ar[s]);</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=(s+e)&gt;&gt;<span class="number">1</span>, ln=<span class="number">2</span>*n, rn=<span class="number">2</span>*n+<span class="number">1</span>;  <span class="comment">//length = 2^k= (e-s+1) = 2*(mid-l+1) </span></span><br><span class="line">		<span class="built_in">bt</span>(ln,s,mid); <span class="built_in">bt</span>(rn,mid+<span class="number">1</span>,e);</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=mid-s;i++) &#123;<span class="comment">// i ~[0, 2^(k-1)]</span></span><br><span class="line">			t[n][i] = <span class="built_in">node</span>(t[ln][i],t[rn][i]); <span class="comment">// &lt; 2^(k-1)</span></span><br><span class="line">			t[n][i+mid-s+<span class="number">1</span>] = <span class="built_in">node</span>(t[rn][i],t[ln][i]); <span class="comment">// &gt;= 2^(k-1), elegant, now ln &amp; rn are swaping</span></span><br><span class="line">		&#125;							</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	N=<span class="built_in">read</span>(); M=(<span class="number">1</span>&lt;&lt;N);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)</span><br><span class="line">		ar[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="built_in">bt</span>(<span class="number">1</span>,<span class="number">1</span>,M);</span><br><span class="line">	Q=<span class="built_in">read</span>(); <span class="type">int</span> cur=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line">		<span class="type">int</span> K=<span class="built_in">read</span>();</span><br><span class="line">		cur^=(<span class="number">1</span>&lt;&lt;K);</span><br><span class="line">		cout &lt;&lt; t[<span class="number">1</span>][cur].mx &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>别忘了你的 resize !</p>
<h3 id="f-2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1716/problem/F">F</a></h3>
<p>斯特林数与下降幂……咕咕</p>
<h2 id="codeforces-round-812-div2-2286"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713">Codeforces round 812 (#Div2)
22/8/6</a></h2>
<p><span class="math inline">\((1749\rightarrow1735,
rk1538)\)</span><br />
ABC 战神, 勇于跳 D 开 E 不跟榜还观察不出来 D 性质的傻子,
罚时与罚坐大师今天又掉分了……(不是三个人, 是一个人)</p>
<h3 id="d交互"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/problem/D">D(交互)</a></h3>
<p>题意：<br />
<span class="math inline">\(2^n\)</span>个人打比赛, 赢者晋级输者淘汰,
最多 <span class="math inline">\(\lceil\frac{1}{3}*
2^{n+1}\rceil\)</span> 次询问任意两个人的胜利次数大小关系,
问谁是最后的赢家。<br />
思路：<br />
数学很好的你一眼就注意到 <span
class="math inline">\(\lceil\frac{1}{3}*  2^{n+1}\rceil=\lceil\frac{2}{3}*
2^{n}\rceil\)</span> (废话),<br />
又注意到了 <span
class="math inline">\(2*\sum\limits_{i=1}^{\infty}{\frac{1}{4^n}}=\frac{2}{3}\)</span>,
一下子就发现了只要每四人一组, 用两次询问得到四人中的赢家,
向上递归便能轻松解题。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/submission/167341869">link</a></p>
<h3 id="e-8"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/problem/E">E</a></h3>
<p>题意：<br />
给一个矩阵, 每次可以选一个 <span class="math inline">\(k\)</span>
并交换所有的 <span class="math inline">\(a[i][k], a[k][i]\)</span>,
问可能得到的最小字典序的矩阵。<br />
思路：<br />
  显然对于矩阵上的一格 <span class="math inline">\(a[i][j]\)</span>,
有唯一对应的 <span class="math inline">\(a[j][i]\)</span> , 选择 <span
class="math inline">\(i, j\)</span> 均可完成交换, 若交换, 则两者选其一;
若不交换, 则两者均选或均不选。<br />
考虑种类并查集, 开两倍的并查集, 注意当两者关系已确定后不再更新。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/submission/168287927">link</a><br />
不会卡常……警示后人, 用 ‘' 换掉你的 'endl'。</p>
<h3 id="f-3"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1713/problem/F">F</a></h3>
<p>FMT……, 要咕一辈子了</p>
<h2 id="codeforces-round-813-div2-22813"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712">Codeforces round 813 (#Div2)
22/8/13</a></h2>
<p><span class="math inline">\((1735\rightarrow1729,
rk1599)\)</span><br />
  这场 135 mins, ABC 做完只用了 20mins 左右, 我以为 D 稳了,
先罚坐了一个小时, 静下心来想和之前的 809E 很像,
都有一个点两两联通的无向图, 也可以按照顺序拆成链, 遂码之,
最后样例测过了, 我交上去, 以为还有一分钟,
但我电脑卡延迟了……实际上比赛已经结束了, 现在是 8/14, 1:28am,
我紧张的等待 system test 结束后想再交一发……我既期冀着打破 ABC 的魔咒,
又有一点不希望自己能成功……看别人写的都是二分, 而我用上了线段树……<br />
交了一发, D 错了, 去睡觉了……</p>
<h3 id="d-6"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/problem/D">D</a></h3>
<p>题意：<br />
给你一个数组 <span class="math inline">\(a\)</span> , 可以更改其中的
<span class="math inline">\(k\)</span> 个数, 图上两点 <span
class="math inline">\(i, j(i&lt;j)\)</span> 的边权为 <span
class="math inline">\(min([a_{i}\dots a_{j}])\)</span> ,
问你能得到的最大树的直径为多少。<br />
思路：<br />
注意到树的直径一定从相邻两点的距离中选出, 假设非相邻两点的距离是直径,
两点之间的最短路只会从 <span class="math inline">\(min(a_{i},a_{j}), 2*
min([a_{1}\dots a_{n}])\)</span> 中取得, 可以观察到走三步以上没有意义,
走两步最小值的构造方法是：看 <span class="math inline">\(a\)</span>
中最小值在起点( <span class="math inline">\(a_{i}\)</span>
)的左边或右边, 然后先去左边的 <span
class="math inline">\(a_{1}\)</span>(或右边的 <span
class="math inline">\(a_{n}\)</span> )再回到 <span
class="math inline">\(a_{j}\)</span> 即可。这样看来,
最长的最短路一定在相邻两点间取得。<br />
从 <span class="math inline">\(a_{i}\)</span> 到 <span
class="math inline">\(a_{i+1}\)</span> 有三种走法：直接走 i--j, 走 i--1,
1--i+1, 走 i--n, n--i+1, 第二、三种走法要求我们预处理出前缀,
后缀最小值。<br />
现在便有了一个二分做法：二分出 mid , 将前缀后缀 <span
class="math inline">\(2* a_{i} \leq mid\)</span> 的值修改,
看修改的数目与 <span class="math inline">\(k\)</span> 的关系, 复杂度
<span class="math inline">\(O(n log n)\)</span><br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/submission/168215506">link</a></p>
<h3 id="e1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/problem/E1">E1</a></h3>
<p>题意：<br />
给你 <span class="math inline">\(l, r\)</span> , 找出满足 <span
class="math inline">\(lcm(i,j,k) \geq i+j+k\)</span> 的三元组 <span
class="math inline">\((i,j,k)\)</span> 数目, 其中 <span
class="math inline">\(l \leq i&lt;j&lt;k \leq r\)</span>, <span
class="math inline">\(l,r \leq 2e5\)</span> 最多五组数据。<br />
思路：<br />
正难则反, 思考计算 <span class="math inline">\(lcm(i,j,k) &lt;
i+j+k\)</span> 的三元组数目, 注意到 <span
class="math inline">\(lcm(i,j,k)\)</span> 为 <span
class="math inline">\(k\)</span> 的倍数, 因为 <span
class="math inline">\(2* k \leq i+j+k &lt; 3* k\)</span> ,
所以所有不合法的三元组必须满足以下条件：<br />
<span class="math display">\[lcm(i,j,k)=k\;\;or\;\;lcm(i,j,k)=2k,
i+j&gt;k\]</span><br />
只要枚举 <span class="math inline">\(k\)</span> 的约数, <span
class="math inline">\(2k\)</span> 的约数即可。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ll sum=(ll)(r-l+<span class="number">1</span>)*(r-l)*(r-l<span class="number">-1</span>)/<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> num=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">2</span>;i&lt;=r;i++)&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> x: fac[<span class="number">2</span>*i])&#123; <span class="comment">//k = i</span></span><br><span class="line">		<span class="keyword">if</span>(x&lt;=l) <span class="keyword">continue</span>; <span class="comment">//j &gt; l </span></span><br><span class="line">		<span class="keyword">if</span>(i%x&amp;&amp;<span class="number">2</span>*x&lt;=i) <span class="keyword">continue</span>; <span class="comment">// continue if x is the factor of 2k but x+y&lt;k  (2k part)</span></span><br><span class="line">		<span class="keyword">if</span>(x&gt;=i) <span class="keyword">break</span>; <span class="comment">//x = j &lt; k</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> y: fac[<span class="number">2</span>*i])&#123; <span class="comment">//y = i &lt; j = x &lt;k</span></span><br><span class="line">			<span class="keyword">if</span>(y&lt;l) <span class="keyword">continue</span>;<span class="comment">// i &gt;= l</span></span><br><span class="line">			<span class="keyword">if</span>(y&gt;=x) <span class="keyword">break</span>; <span class="comment">//i &lt; j</span></span><br><span class="line">			<span class="keyword">if</span>(i%x||i%y) <span class="comment">// x/y is factor of 2k (2k part)</span></span><br><span class="line">				num+= (x+y&gt;i); <span class="comment">//can they?</span></span><br><span class="line">			<span class="keyword">else</span> num++; <span class="comment">//x/y is factor of k</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum-num &lt;&lt; endl;</span><br></pre></td></tr></table></figure> 用 <span class="math inline">\(2k\)</span> 的约数做 <span
class="math inline">\(k\)</span> 的约数, 在其中再特判 <span
class="math inline">\(2k\)</span> 的约数。</p>
<h3 id="e2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/problem/E2">E2</a></h3>
<p>题意同上, 最多可能有 2e5 组数据。<br />
思路：<del>E1都是贺的我 E2 有屁思路</del><br />
  考虑离线下来做, 同上, 从小到大枚举 <span
class="math inline">\(k\)</span> , 将 <span
class="math inline">\((i,j,k)\)</span> 中所有有贡献的 <span
class="math inline">\(i\)</span> 及其贡献(固定 <span
class="math inline">\(i,k\)</span> 后的三元组数目)用树状数组单点修改,
每次枚举完 <span class="math inline">\(k\)</span> 后查看是否有 <span
class="math inline">\(r=k\)</span> 的询问, 其答案便为树状数组上 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(k\)</span> 的区间求和。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/submission/168267013">link</a></p>
<h3 id="f-4"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1712/problem/F">F</a></h3>
<p>长链剖分, 咕。</p>
<h2 id="codeforces-round-814-div2-22816"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1719">Codeforces round 814 (#Div2)
22/8/16</a></h2>
<p><span class="math inline">\((1729\rightarrow1774,
rk501)\)</span><br />
ABC 战神糊出来了 D1 , 上了小分。</p>
<h3 id="d2-2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1719/problem/D2">D2</a></h3>
<p>题意：<br />
给你大小为 <span class="math inline">\(N\)</span> 的数组 <span
class="math inline">\(a\)</span> , 每次可以选择 <span
class="math inline">\(l, r, x\)</span> 使得 <span
class="math inline">\([l,r]\)</span> 范围内的数全部异或 <span
class="math inline">\(x\)</span> , 并耗费 <span
class="math inline">\(\lceil \frac{r-l+1}{2}\rceil\)</span> 的代价, 问将
<span class="math inline">\(a\)</span> 数组全部置零的最小代价。<span
class="math inline">\(N \leq 2e5\)</span> 。<br />
思路：<br />
  因为有上取整的要求, 一次操作范围为 2 的数字是最赚的,
范围再扩大则没有必要, 原先的 D1, <span class="math inline">\(N\)</span>
的范围在 <span class="math inline">\(5000\)</span> 以内, 可以暴力二维
<span class="math inline">\(DP\)</span> ,
原先有一个简单的置零方法就是一个一个置零, 代价为 <span
class="math inline">\(N\)</span>, 我们每两个两个操作就可能省下一个代价,
我的 D1 做法是设 <span class="math inline">\(f_{i,j}\)</span> 为考虑省下
<span class="math inline">\(i\)</span> 处代价, 从头一直处理到 <span
class="math inline">\(j\)</span> 处所省下的代价。<br />
<span
class="math display">\[f_{i,j}=max(f_{1,i-1},f_{2,i-1},...,f_{i-1,i-1})+[a_{i}
\oplus a_{i+1} \oplus ... \oplus a_{j} == 0]\]</span><br />
最后取 <span
class="math inline">\(N-max(f_{1,N},f_{2,N},...,f_{N,N})\)</span>
为答案, 有点玄学, 我也不知道怎么过的题, 复杂度 <span
class="math inline">\(O(n^2)\)</span> 。<br />
事实上我们可以直接设 <span class="math inline">\(f_{i}\)</span> 为将
<span class="math inline">\(1...i\)</span> 所有数置零付出的最小代价,
要么我们操作长度为 1 的数组一次, 要么我们一直操作长度为 2
的数组直到某段区间的异或和为零。<br />
<span class="math display">\[f_{i}=min(f_{i-1}+1, \underset
{a_{j+1}\oplus a_{j+2} \oplus...\oplus
a_{i}=0}{min}(f_{j}+i-j-1))\]</span> 复杂度也是 <span
class="math inline">\(O(n^2)\)</span> , 但应该有了些优化空间,
比如把最小的 <span class="math inline">\(f_{j}-j\)</span> 存入 <span
class="math inline">\(map\)</span> 中, 事实上, 我们还可以设 <span
class="math inline">\(xors_{i}=a_{1} \oplus a_{2} \oplus ...\oplus
a_{i}\)</span> , 那么有 <span class="math inline">\(a_{j+1}\oplus
a_{j+2} \oplus...\oplus a_{i}=0 \Longleftrightarrow
xors_{j}=xors_{i}\)</span> 这样一个小性质。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	ar[i]=<span class="built_in">read</span>(); f[i]=inf;</span><br><span class="line">	xors[i]=xors[i<span class="number">-1</span>]^ar[i];</span><br><span class="line">&#125;</span><br><span class="line">MII mp;</span><br><span class="line">mp[<span class="number">0</span>]=<span class="number">0</span>; <span class="comment">//记录前缀和i所对应的最小 f[j]-j</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(!ar[i]) f[i]=<span class="built_in">min</span>(f[i], f[i<span class="number">-1</span>]);</span><br><span class="line">	<span class="keyword">else</span> f[i]=<span class="built_in">min</span>(f[i],f[i<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(mp.<span class="built_in">find</span>(xors[i])!=mp.<span class="built_in">end</span>())</span><br><span class="line">		f[i]=<span class="built_in">min</span>(f[i],mp[xors[i]]+i<span class="number">-1</span>);</span><br><span class="line">	mp[xors[i]]=<span class="built_in">min</span>(mp[xors[i]],f[i]-i);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; f[N] &lt;&lt; endl;</span><br></pre></td></tr></table></figure> 弄一下就 <span
class="math inline">\(O(n\;log\;n)\)</span> 了。</p>
<h3 id="e-9"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1719/problem/E">E</a></h3>
<p>题意：<br />
  <span class="math inline">\(k\)</span> 种字符, 每种 <span
class="math inline">\(a_{1}, a_{2},...,a_{k}\)</span> 个,
问是否能用它组成一个字符串 <span class="math inline">\(s\)</span> ,
使得：字符串中的每一段连续相同字母个数重新组合后是斐波那契数列的前几项。<br />
思路：<br />
  显然若 <span class="math inline">\(\sum a_{i}\)</span>
不等于斐波那契数列的某个前缀和时可以直接判定不存在。先处理出 <span
class="math inline">\(fib[i]\)</span> , 在用 <span
class="math inline">\(map\)</span> 处理出 <span
class="math inline">\(fib[i]\)</span> 的前缀和, 键值设为 <span
class="math inline">\(i\)</span> , 到 90 项就够了。<br />
然后我们知道了最终要构建的斐波那契数列的项数 <span
class="math inline">\(M\)</span> , 考虑贪心的从高项往低项填充,
可以拉个优先队列实现, 又因为相邻两项字符不能相同,
每次填完后剩下的字符数量隔一轮再加回去。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1719/submission/169204906">link</a></p>
<h3 id="f-5"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1719/problem/F">F</a></h3>
<p>22/10/23, 应 <span
class="math inline">\(\color{black}{\tt{c}}\color{red}{\tt{hengchunhao}}\)</span>
推荐来补题, <span
class="math inline">\(\color{black}{\tt{c}}\color{red}{\tt{hengchunhao}}\)</span>
大队长直言道, 1600的诈骗题不会补, <span
class="math inline">\(\color{blue}{\tt{frankly6}}\)</span>
怕是连面子都不要了。<br />
题意：<br />
一个<strong>循环数组</strong>(<span class="math inline">\(a_{n}\)</span>
后面接 <span class="math inline">\(a_{1}\)</span>), 自选一个位置 <span
class="math inline">\(s\)</span> 开始跳 <span
class="math inline">\(n\)</span> 步, 步长 <span class="math inline">\(k
&lt; n\)</span> , 每次把那个位置上的数加入到 "有用值" 中去。 有 <span
class="math inline">\(Q\)</span> 次单点修改, <span
class="math inline">\(a_{p}=v\)</span> , 修改不独立, 问这 <span
class="math inline">\(Q+1\)</span> 次的 <span
class="math inline">\(Q+1\)</span> 个最大有用值。<br />
<span class="math inline">\(n,Q \leq 2e5, a_{i} \leq 1e9\)</span><br />
思路：<br />
只会朴素做法……对 <span class="math inline">\(n\)</span> 的所有不等于
<span class="math inline">\(n\)</span> 的约数 <span
class="math inline">\(d\)</span> 作为<strong>步长</strong>, 枚举 <span
class="math inline">\(j \in [0,d-1]\)</span> 作为起始点, 求 <span
class="math inline">\(f(d,j)=d* \sum\limits_{i \equiv
j\;mod\;d}{a_{i}}\)</span> , 再求出最大的 <span
class="math inline">\(f\)</span> , 单次的复杂度应该是 <span
class="math inline">\(O(n* d(n))\)</span> 的。<br />
可以手玩小样例来优化, 设 <span class="math inline">\(n=12\)</span>,
<strong>步长</strong> <span class="math inline">\(k=2,3,6\)</span>
:<br />
1.<span class="math inline">\(k=2, ans=2 *
max(a_{1}+a_{3}+a_{5}+a_{7}+a_{9}+a_{11},a_{2}+a_{4}+a_{6}+a_{8}+a_{10}+a_{12})\)</span><br />
2.<span class="math inline">\(k=3, ans=3 *
max(a_{1}+a_{4}+a_{7}+a_{10},a_{2}+a_{5}+a_{8}+a_{11},a_{3}+a_{6}+a_{9}+a_{12})\)</span><br />
3.<span class="math inline">\(k=6, ans=6 *
max(a_{1}+a_{7},a_{2}+a_{8},a_{3}+a_{9},a_{4}+a_{10},a_{5}+a_{11},a_{6}+a_{12})\)</span></p>
<p>可以看出来 <span class="math inline">\(k=6\)</span> 一定优于 <span
class="math inline">\(k=2, k=3\)</span> 的答案, 因此若 <span
class="math inline">\(k_{1}|k_{2}\)</span> , 则 <span
class="math inline">\(k_{1}\)</span> 不需要额外求解, 只有当 <span
class="math inline">\(k\)</span> 满足 <span
class="math inline">\(\frac{n}{k}\)</span> 为质数时, 才要求解 <span
class="math inline">\(k\)</span> , 否则 <span
class="math inline">\(\frac{n}{k}\)</span> 可以拆出一个因子安在 <span
class="math inline">\(k\)</span> 身上,
我们只要考虑所有<strong>环长</strong>(<span
class="math inline">\(\frac{n}{k}\)</span>)为质数的环即可。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">	N=<span class="built_in">read</span>(); Q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="type">int</span> tmp=N; cnt=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=tmp;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(tmp%i==<span class="number">0</span>)&#123;</span><br><span class="line">			d[++cnt]=N/i;  <span class="comment">// N/d = N/(N/i) = i = PRIME!</span></span><br><span class="line">			<span class="keyword">while</span>(tmp%i==<span class="number">0</span>) tmp/=i;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=d[i]<span class="number">-1</span>;j++) f[j][i]=<span class="number">0</span>; <span class="comment">// f[j][i] = f(cnt[i],j), cnt[i] is the length of a step.</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++) f[j%d[i]][i]+=ar[j]; <span class="comment">//congruence modulo and solve</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=d[i]<span class="number">-1</span>;j++) s.<span class="built_in">insert</span>(d[i]*f[j][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">//rbegin() = end()-1 </span></span><br><span class="line">	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">		<span class="type">int</span> p=<span class="built_in">read</span>(), x=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">			s.<span class="built_in">erase</span>(s.<span class="built_in">find</span>(d[i]*f[p%d[i]][i])); <span class="comment">// must use s.find() or it will delete all elements</span></span><br><span class="line">			f[p%d[i]][i]+=x-ar[p];</span><br><span class="line">			s.<span class="built_in">insert</span>(d[i]*f[p%d[i]][i]);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; *s.<span class="built_in">rbegin</span>() &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		ar[p]=x;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="codeforces-round-816-div2-22820"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1715">Codeforces round 816 (#Div2)
22/8/20</a></h2>
<p><span class="math inline">\((1774\rightarrow1764,
rk1256)\)</span><br />
可能会 D , 但 WA on pretest 4 三发, 遂摆之。</p>
<h3 id="d-7"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1715/problem/D">D</a></h3>
<p>题意：<br />
  给你长度为 <span class="math inline">\(N\)</span> 的数组 <span
class="math inline">\(a\)</span> ， <span
class="math inline">\(Q\)</span> 个约束条件, 每个约束条件 <span
class="math inline">\((i,j,x)\)</span> 表示 <span
class="math inline">\(a_{i}|a_{j}=x\)</span> , 要你构造一个满足 <span
class="math inline">\(Q\)</span> 个约束条件的字典序最小的数组, <span
class="math inline">\(a_{i} &lt; 2^{30}\)</span>。<br />
思路：<br />
  按位把询问的 <span class="math inline">\(x\)</span> 拆开来, 若 <span
class="math inline">\(x\)</span> 的某一位为零则 <span
class="math inline">\(a, b\)</span> 的对应位全为零, 若 <span
class="math inline">\(x\)</span> 的某一位为一则 <span
class="math inline">\(a, b\)</span> 的对应位至少有一个一。若 <span
class="math inline">\(a=b\)</span> 则那个数字对应 <span
class="math inline">\(x\)</span> 。我们可以先初始化 <span
class="math inline">\(a\)</span> 的每一位为 <span
class="math inline">\(2^{30}-1\)</span> (所有位都为 1 ), 用 vector<PII>
把询问都挂上去, 从前往后, 从高位到低位尝试置零。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); Q=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=(<span class="number">1</span>&lt;&lt;<span class="number">30</span>)<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=Q;i++)&#123;</span><br><span class="line">	<span class="type">int</span> a=<span class="built_in">read</span>(), b=<span class="built_in">read</span>(), val=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(a==b) &#123;ar[a]=val; vis[a]=<span class="number">1</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">29</span>;k&gt;=<span class="number">0</span>;k--)&#123;</span><br><span class="line">		<span class="keyword">if</span>((val&gt;&gt;k)&amp;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">if</span>((ar[a]&gt;&gt;k)&amp;<span class="number">1</span>) ar[a]^=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">		<span class="keyword">if</span>((ar[b]&gt;&gt;k)&amp;<span class="number">1</span>) ar[b]^=(<span class="number">1</span>&lt;&lt;k);</span><br><span class="line">	&#125;</span><br><span class="line">	v[a].<span class="built_in">push_back</span>(&#123;b,val&#125;);</span><br><span class="line">	v[b].<span class="built_in">push_back</span>(&#123;a,val&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(vis[i]) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">29</span>;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(!((ar[i]&gt;&gt;j)&amp;<span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">		<span class="type">bool</span> tag=<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> k:v[i])&#123;</span><br><span class="line">			<span class="type">int</span> b=k.first, val=k.second;</span><br><span class="line">			<span class="keyword">if</span>(((val&gt;&gt;j)&amp;<span class="number">1</span>)&amp;&amp;!((ar[b]&gt;&gt;j)&amp;<span class="number">1</span>)) &#123;tag=<span class="number">0</span>; <span class="keyword">break</span>;&#125; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tag) ar[i]^=(<span class="number">1</span>&lt;&lt;j);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) cout &lt;&lt; ar[i] &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h3 id="e-10"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1715/problem/E">E</a></h3>
<p>(于22/11/2日补题……) 斜率优化DP<br />
题意：<br />
  有 <span class="math inline">\(n\)</span> 座城市, 城市间有 <span
class="math inline">\(m\)</span> 条双向道路, 通过第 <span
class="math inline">\(i\)</span> 条道路需要花费 <span
class="math inline">\(w_{i}\)</span> 时间,
两两城市(u,v)之间还可以坐飞机来通行, 花费为 <span
class="math inline">\((u-v)^2\)</span> , 你最多可以做 <span
class="math inline">\(k\)</span> 次飞机, 问 <span
class="math inline">\(1\)</span>
号城市到所有城市的最短时间为多少。<br />
<span class="math inline">\(n, m \leq 1e5, k \leq 20, w_{i} \leq
1e9\)</span><br />
思路：<br />
  <span class="math inline">\(dijkstra\)</span> 是肯定要做的, 看到 <span
class="math inline">\(k\)</span> 这么小, 可以想到分层图。<br />
  设 <span class="math inline">\(f[i][k]\)</span> 表示乘坐 <span
class="math inline">\(\leq k\)</span> 次航班从 <span
class="math inline">\(1\)</span> 点到 <span
class="math inline">\(i\)</span> 点且最后一次航班直接到达 <span
class="math inline">\(i\)</span> 点的最短时间, <span
class="math inline">\(dis[i][k]\)</span> 表示乘坐 <span
class="math inline">\(\leq k\)</span> 次航班从 <span
class="math inline">\(1\)</span> 点到 <span
class="math inline">\(i\)</span> 点的最短时间。我们先跑一遍 <span
class="math inline">\(dijkstra\)</span> 求出 <span
class="math inline">\(dis[i][0]\)</span> , 接下来考虑转移, 有：<br />
<span class="math display">\[f[i][k]=min\{dis[j][k-1]+(i-j)^2\}, j\in
[1,n]\]</span><br />
这个复杂度是 <span class="math inline">\(O(n^2)\)</span> 的,
我们拆一下式子：<br />
<span
class="math display">\[f[i][k]=dis[j][k-1]+i^2+j^2-2*i*j\]</span><br />
<span class="math display">\[\underline{dis[ j ][ k-1 ] + j^2}_y =
\underline{2*i}_k * \underline{j}_x + \underline{f[ i ][ k ] -
i^2}_b\]</span><br />
  一开始看到平方贡献你就能想到斜率优化了, 现在是个典型的斜率优化式子,
控制枚举顺序, 我们可以让 <span class="math inline">\(k,x\)</span> 单增,
因为 <span class="math inline">\(b\)</span> 要最小, 维护下凸壳,
于是我们可以 <span class="math inline">\(O(n)\)</span> 更新所有的 <span
class="math inline">\(f[i][k]\)</span> , 然后我们再拿着 <span
class="math inline">\(f[i][k]\)</span> 跑 <span
class="math inline">\(dijkstra\)</span> 更新 <span
class="math inline">\(dis[i][k]\)</span> , 重复 <span
class="math inline">\(k\)</span> 次就行了, 复杂度 <span
class="math inline">\(O(kn \;log\;n)\)</span>。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1715/submission/178922436">link</a></p>
<h3 id="f-6"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1715/problem/F">F</a></h3>
<p>咕咕, 咕咕咕！！</p>
<h2 id="educational-codeforces-round-134-div2-22827"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1721">Educational codeforces round
134 (#Div2) 22/8/27</a></h2>
<p><span class="math inline">\((1764\rightarrow1650,
rk4729)\)</span><br />
大寄特寄, 只会 AB。一个暑假, 除了心态进步, 其余都不曾改变, 上个 edu
场涨的分全掉回来了,
现在凌晨整个人非常清醒......清醒着沉沦......差不多吧。</p>
<h3 id="d-8"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1721/problem/D">D</a></h3>
<p>题意：<br />
  给你两个数组 <span class="math inline">\(a, b\)</span> , 你要调整
<span class="math inline">\(b\)</span> 数组的顺序, 使得构造出来的 <span
class="math inline">\(c\)</span> 数组(<span
class="math inline">\(c_{i}=a_{i}\oplus b_{i}\)</span>) 与起来的和最大
(<span class="math inline">\(d=c_{1} \&amp;c_{2} \&amp;
...\&amp;c_{N}\)</span> 最大)<br />
思路：<br />
  显然要从高往低做, 要想 <span class="math inline">\(d\)</span>
的二进制中某一位为 <span class="math inline">\(1\)</span> , 就要判断
<span class="math inline">\(a\)</span> 中 <span
class="math inline">\(1\)</span> 的个数是否等于 <span
class="math inline">\(b\)</span> 中 <span
class="math inline">\(0\)</span> 的个数, 这样我们能把数组拆成 "a0b1" 和
"a1b0" 两部分, 接下来在两部分内分别递归向下检查就行了。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">T=<span class="built_in">read</span>();</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; a, b, ord;</span><br><span class="line">	vector&lt;pair&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt;&gt; t;</span><br><span class="line">	N=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) a.<span class="built_in">push_back</span>(<span class="built_in">read</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) b.<span class="built_in">push_back</span>(<span class="built_in">read</span>());</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;N;i++) ord.<span class="built_in">push_back</span>(i); <span class="comment">//equals to &quot;iota(ord.begin(), ord.end(), 0);&quot; (c++11)</span></span><br><span class="line">	t.<span class="built_in">emplace_back</span>(ord,ord);</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">29</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="type">bool</span> tag=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> tmp:t)&#123;</span><br><span class="line">			<span class="keyword">auto</span> va=tmp.first, vb=tmp.second;</span><br><span class="line">			<span class="type">int</span> cnta=<span class="number">0</span>, cntb=<span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:va) <span class="keyword">if</span>(a[x]&gt;&gt;i&amp;<span class="number">1</span>) cnta++;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> y:vb) <span class="keyword">if</span>(b[y]&gt;&gt;i&amp;<span class="number">1</span>) cntb++;</span><br><span class="line">			<span class="keyword">if</span>(cnta+cntb!=va.<span class="built_in">size</span>()) &#123;tag=<span class="number">1</span>; <span class="keyword">break</span>;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(tag) <span class="keyword">continue</span>;</span><br><span class="line">		ans |= <span class="number">1</span>&lt;&lt;i;</span><br><span class="line">		vector&lt;pair&lt;vector&lt;<span class="type">int</span>&gt;, vector&lt;<span class="type">int</span>&gt;&gt;&gt; t2;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> tmp:t)&#123;</span><br><span class="line">			<span class="keyword">auto</span> va=tmp.first, vb=tmp.second;</span><br><span class="line">			vector&lt;<span class="type">int</span>&gt; a1, a0, b1, b0;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> x:va)&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[x]&gt;&gt;i&amp;<span class="number">1</span>) a1.<span class="built_in">push_back</span>(x);</span><br><span class="line">				<span class="keyword">else</span> a0.<span class="built_in">push_back</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">auto</span> y:vb)&#123;</span><br><span class="line">				<span class="keyword">if</span>(b[y]&gt;&gt;i&amp;<span class="number">1</span>) b1.<span class="built_in">push_back</span>(y);</span><br><span class="line">				<span class="keyword">else</span> b0.<span class="built_in">push_back</span>(y);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(a0.<span class="built_in">size</span>()) t2.<span class="built_in">emplace_back</span>(a0,b1);</span><br><span class="line">			<span class="keyword">if</span>(a1.<span class="built_in">size</span>()) t2.<span class="built_in">emplace_back</span>(a1,b0);	</span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="built_in">swap</span>(t,t2);</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>);		</span><br></pre></td></tr></table></figure> 写得很精妙……是的, auto 拆开来写的……那玩意好像是 c++17
的结构化绑定……devc++不支持……以及我也不知道代码中的 <span
class="math inline">\(push\_back\)</span> 为什么会报错, 换成 <span
class="math inline">\(emplace\_back\)</span> 竟然就没事了……</p>
<h3 id="e-11"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1721/problem/E">E</a></h3>
<p>持久化 KMP , 咕</p>
<h3 id="f-7"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1721/problem/F">F</a></h3>
<p>题意：<a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/rqiydki9">太长机翻</a><br />
思路：<br />
  二分图中, 最大匹配 = 最小点覆盖 = 总点数 - 最大独立集。<br />
  于是跑完 Dinic 后求最大独立集的补集, 在残留网络上跑 dfs ,
选择左边点集没取到的和右边点集取到的(这一步是选出补集),
再存一下边就做完了。口胡一下正确性, 左边点集取到了说明没有被匹配过,
一定在最大独立集里, 而为了 "独立" , 右边就要取取到过的点了,
因为我们还要取补集, 便得到了上述的结论。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1721/submission/171571065">link</a></p>
<h2 id="codeforces-round-818-div2-2292"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1717">Codeforces round 818 (#Div2)
22/9/2</a></h2>
<p><span class="math inline">\((1650\rightarrow1701,
rk773)\)</span><br />
  八发罚时可谓是人麻了, 甚至交上去一发带 freopen 的, C 糊过的, D
抄的自己的逆元板子, 我对这场的评价是有思维性, 因为 A 就卡了十分钟……</p>
<h3 id="e-12"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1717/problem/E">E</a></h3>
<p>题意：<br />
给你 <span class="math inline">\(N\)</span> , 让你计算 <span
class="math inline">\(\sum lcm(c,gcd(a,b))\)</span> , 对于所有满足 <span
class="math inline">\(a+b+c=N\)</span> 的三元组,
所有数都是正整数。<br />
思路：<br />
  小清新数论题, 找一个刁钻的角度枚举, <del>一眼瞪出</del>枚举 <span
class="math inline">\(gcd(a,b)\)</span> , 然后不会力。<br />
  设 <span class="math inline">\(gcd(a,b)=t\)</span> , 原式转化为 <span
class="math inline">\(\sum lcm(c,t) \sum_{a+b=N-c} [gcd(a,b)=t]\)</span>
看上去是无用的转换, 问题是如何计算 <span
class="math inline">\([gcd(a,b)=t]\)</span> 的个数, 但聪明的你两眼瞪出
<span class="math inline">\(gcd(a,b)=t \Leftrightarrow gcd(\frac{a}{t},
\frac{b}{t})=1\)</span> , 又想到了此时 <span
class="math inline">\(\frac{a}{t}+\frac{b}{t}=\frac{N-c}{t}\)</span> ,
三眼又瞪出一个重要结论：<br />
<strong>若正整数 a+b = c , 则 a 与 b 互质的充要条件是 a 与 c
互质</strong><br />
证明很简单, 若 <span class="math inline">\(gcd(a,b)=u&gt;1\)</span> , 则
<span class="math inline">\(u|c\)</span> , <span
class="math inline">\(gcd(a,c)&gt;0\)</span> ;<br />
若 <span class="math inline">\(gcd(a,c)=u&gt;0\)</span> , 则因为 <span
class="math inline">\(b=c-a\)</span> , <span
class="math inline">\(u|b\)</span> , 矛盾。<br />
所以我们最后的结论是：<br />
满足 <span class="math inline">\(gcd(a,b)=t\)</span> 的式子个数, 即为与
<span class="math inline">\(\frac{N-c}{t}\)</span> 互质的正整数个数, 即
<span class="math inline">\(\varphi(\frac{N-c}{t})\)</span><br />
我们要求的转化为 <span class="math inline">\(\sum lcm(c,t)
\varphi(\frac{N-c}{t})\)</span> , 注意 <span
class="math inline">\(\frac{N-c}{t} \neq 1\)</span> , 否则找不到正整数
<span class="math inline">\(a, b\)</span>。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1717/submission/170797110">link</a></p>
<h3 id="f-8"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1717/problem/F">F</a></h3>
<p>题意：<br />
  给定长度为 <span class="math inline">\(N\)</span> , 初始数组全为 <span
class="math inline">\(0\)</span> 的数组 <span
class="math inline">\(b\)</span> , 以及 <span
class="math inline">\(m\)</span> 对 <span
class="math inline">\([u,v]\)</span>, 对于每对 <span
class="math inline">\([u,v]\)</span> , 你可以且必须选择 <span
class="math inline">\(b[u]--, b[v]++\)</span> 或 <span
class="math inline">\(b[v]--, b[u]++\)</span> 一次, 又给定一个 <span
class="math inline">\(01\)</span> 数组 <span
class="math inline">\(s\)</span> , 一个数组 <span
class="math inline">\(a\)</span> , 问是否存在一种选择方案, 使得： <span
class="math display">\[\forall s[i] \neq 0, b[i]=a[i]\]</span><br />
思路：<br />
  点对就是点对, 即使它叫做 <span class="math inline">\([u,v]\)</span>
也是点对, 你要把它看成一条边来搞网络流的话,
怎么保证这条边一定被选中呢?(我一开始还想再套个费用流, 寄!)<br />
  考虑原问题的等价条件, 一个 +1, 一个 -1, 等价于两个 <span
class="math inline">\(b_{i}, b_{j}\)</span> 都 -1, 再选一个 +2,
等价于两个 <span class="math inline">\(a_{i}, a_{j}\)</span> 都 +1,
再选一个 -2, 问题转化为图的匹配, 无向边就没了, 把点对看成点, 往 u, v
各连一条容量为 1 的边, S(源点) 连点对, a 数组(对应的 <span
class="math inline">\(s[i] \neq 0\)</span> 的部分)连 T(汇点), 容量为
<span class="math inline">\(a_{i}/2\)</span> ;<br />
  如何保证所有的点对都被用掉？ 我们可以让那些点对在 <span
class="math inline">\(s[i]=0\)</span> 的 <span
class="math inline">\(a[i]\)</span> 上 "宣泄" 流量, 让 <span
class="math inline">\(s[i]=0\)</span> 的点连一条 inf 流量的边到中转点,
再从中转点连一条容量为 <span class="math inline">\(M-\sum
a_{i}[s[i]==1]\)</span> 的边到汇点。<br />
  然后贺你的 Dinic 模版, 再检查一下流量大小与方向, 就行了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1717/submission/171478369">link</a><br />
  有很多小细节, 总的流量要为 M, <span
class="math inline">\(s[i]=1\)</span> 的 <span
class="math inline">\(a[i]\)</span> 流量要跑满, <span
class="math inline">\(a[i]\)</span> 更新后不为正偶数直接退出。</p>
<h2 id="codeforces-round-819-div12-2296"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1726">Codeforces round 819
(#Div1+2) 22/9/6</a></h2>
<p><strong>UNRATED</strong></p>
<p>  早上到机房一看, 出题人抄了 F 题(本场 A-H, 135mins)被发现, unrated
了, 乐。<br />
  反正我也做不到 F......, 补题还是要补的, 昨晚打的很奇妙, 个人体验 B
&gt;&gt; C , 反正 B 我还猜了一个小结论, 用时 30 mins(寄定了), C 只用了 6
mins, 剩下 90 mins 在 DEF 之间来回跳, 0:30 熬不下去了, 3
题含恨离场。</p>
<h3 id="d-9"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1726/problem/D">D</a></h3>
<p>题意：<br />
  <span class="math inline">\(N\)</span> 个点, <span
class="math inline">\(M\)</span> 条边, 联通的无向图, 无自环, 重边, <span
class="math inline">\(M \leq N+2\)</span> , 给你图的结构,
对边进行红蓝染色, 设只考虑红色边时的联通分量数为 <span
class="math inline">\(c_{1}\)</span> , 只考虑蓝色边时的联通分量数为
<span class="math inline">\(c_{2}\)</span> , 问一种染色方法使得 <span
class="math inline">\(c_{1}+c_{2}\)</span> 最小。<br />
思路：<br />
  生成树肯定是要求的, dfs 一遍即可, 剩下最多 3 个点(N+2-(N-1)=3)
全部染成另外一种颜色(这里指蓝色吧), 若最小化 <span
class="math inline">\(c_{1}+c_{2}\)</span> , 则剩下的 3 个点不能成环,
我们要选择一条环上的边, 染成红色, 环转移到了生成树上,
我们再把这条边的一个端点连接的其他所有边染成蓝色,
这样我们保留了生成树的同时也拆掉了环。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1726/submission/171180862">link</a></p>
<h3 id="e-13"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1726/problem/E">E</a></h3>
<p>题意：<br />
  对于一个长度为 <span class="math inline">\(n\)</span> 的排列 <span
class="math inline">\(p\)</span> , 若当 <span class="math inline">\(1
\leq i \leq n\)</span> 时都有 <span
class="math inline">\(|p_{i}-p_{i}^{-1}| \leq 1\)</span> 时我们称它是
"几乎完美" 的。(<span class="math inline">\(p_{k1}^{-1}=k2\)</span>
当且仅当 <span class="math inline">\(p_{k2}=k1\)</span>)<br />
给你排列的长度 <span class="math inline">\(n\)</span> (<span
class="math inline">\(n \leq 3e5\)</span>), 求出所有 "几乎完美" 的排列,
对 998244353 取模。<br />
思路： 咕, 等我学学排列组合, 不会推这个东西。</p>
<h2 id="educational-codeforces-round-136-div2-2298"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728">Educational codeforces round
136 (#Div2) 22/9/8</a></h2>
<p><span class="math inline">\((1701\rightarrow1675,
rk1841)\)</span><br />
只会 ABC, 事实证明, 在 edu round , 所有你不会的 STL 都会攻击你……, 写 <a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/submission/1728/171398199">C</a>
还被迫学了 multiset , 一看 <span
class="math inline">\(\color{black}{j}\color{red}{iangly}\)</span>
的代码才发现, 原来只要 priority_queue 啊……, 不过这和我是 ABC
战神没有半点关系, 因为我 D 的 DP 又寄了。</p>
<h3 id="d-10"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728/problem/D">D</a></h3>
<p>题意：<br />
  两人对弈(Alice &amp; Bob),
轮流在给定字符串的头或尾处取走一个字符(Alice 先取),
加到自己字符串的开头, 保证字符串长度 <span
class="math inline">\(N\)</span> 为偶数, 问在最优情况下,
谁的字符串字典序最小(或是平局)。<br />
思路：<br />
  要么 Alice 胜利, 要么平局。 因为最后剩两个字母时 Alice
总可以选取字典序最小的在最前面, 若两字母相同, 则 Alice
之前还是可能有选取更小字典序的机会, 对 Alice 而言最坏是平局。<br />
让我们用 <span class="math inline">\(f_{i,j}\)</span>
表示当字符串为给定字符串 <span class="math inline">\([i,j]\)</span>
的子串时游戏的赢家, <span class="math inline">\(f_{i,j}=1\)</span> 为
Alice 获胜, <span class="math inline">\(f_{i,j}=0\)</span> 时为平局,
<span class="math inline">\(f_{1,N}\)</span> 即为答案。
我们从小区间向大区间递推, 先初始化所有的 <span
class="math inline">\(f_{i,i+1}\)</span> 。<br />
<span class="math display">\[s[i]=s[i+1]
\;?\;f_{i,i+1}=0\;:\;f_{i,i+1}=1\]</span>   然后我们向上递推到长度为
<span class="math inline">\(4, 6, 8, ......\)</span>
的区间。每个上级区间可以看出实际上是由三个重复的下级区间构成的,
我们可以设为 <span class="math inline">\(a,b,c\)</span> ,
目前我们要递推的区间为 <span
class="math inline">\(f_{i,j}\)</span><br />
1. <span class="math inline">\(f_{a}+f_{b}+f_{c}=3, \;
f_{i,j}=1\)</span> 显然。 2. <span
class="math inline">\(f_{a}+f_{b}+f_{c}=2\)</span><br />
2.1. <span class="math inline">\(f_{a}=0 \; || \; f_{c}=0, \;
f_{i,j}=1\)</span> 最左边 / 最右边是平局态, Alice 可以破坏。<br />
2.2. <span class="math inline">\(f_{b}=0 \; \&amp;\&amp; \; s[i] \neq
s[j] , \; f_{i,j}=1\)</span> 中间是平衡态, Alice
可以抢两边字典序小的字符的先手。<br />
2.3. <span class="math inline">\(f_{b}=0 \; \&amp;\&amp; \; s[i] = s[j]
, \; f_{i,j}=0\)</span> Bob 跟 Alice 对偶着下就平局了。<br />
3. <span class="math inline">\(f_{a}+f_{b}+f_{c}=1\)</span><br />
3.1. <span class="math inline">\(f_{a}=0 \; \&amp;\&amp; \; f_{c}=0, \;
f_{i,j}=0\)</span> Bob 可以破坏掉中间 Alice
的胜利状态并留下一个平局状态。<br />
3.2. <span class="math inline">\(f_{b}=0 \; \&amp;\&amp; \; s[i]=s[j],
\; f_{i,j}=0\)</span> 中间平局, 两边无法抢先手, 最终平局。<br />
3.3. <span class="math inline">\(f_{b}=0 \; \&amp;\&amp; \; s[i] \neq
s[j], \; f_{i,j}=1\)</span> 中间平局, 两边可以抢先手, 最终 Alice 胜。 4.
<span class="math inline">\(f_{a}+f_{b}+f_{c}=0\)</span><br />
4.1. <span class="math inline">\(s[i]=s[j], \; f_{i,j}=0\)</span>
中间平局, 两边无法抢先手, 最终平局。<br />
4.2. <span class="math inline">\(s[i] \neq s[j], \; f_{i,j}=1\)</span>
中间平局, 两边可以抢先手, 最终 Alice 胜。</p>
<p>  看着很难, 事实上写的时候很自然, 评分顶多2000,
至于如何不重不漏的转移, 你补题的时候 WA 6发就知道了,
话说应该我转移重了很多......, 不管了。<br />
代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/submission/1728/171454745">link</a></p>
<h3 id="e-14"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728/problem/E">E</a></h3>
<p>题意：<br />
  有 <span class="math inline">\(N\)</span> 盘菜,
每盘加入<strong>一个</strong>红胡椒或黑胡椒获得 <span
class="math inline">\(a_{i}\)</span> 或 <span
class="math inline">\(b_{i}\)</span> 的美味值,
不能都加/都不加/加入超过一个胡椒。<br />
  有 <span class="math inline">\(M\)</span> 家店,
每家卖出<strong>一份</strong>红胡椒或黑胡椒包含 <span
class="math inline">\(x_{j}\)</span> 或 <span
class="math inline">\(y_{j}\)</span> 的对应胡椒,
你需要输出分别<strong>仅</strong>在第 <span
class="math inline">\(j\)</span>
家店买得所有胡椒并<strong>恰好</strong>用完所获得的最大美味值,
若不存在方案输出 <span class="math inline">\(-1\)</span>。<br />
思路：<br />
  小清新数论题, <span class="math inline">\(exgcd\)</span>, 三分,
还考察了二元一次不定方程的通解, 好题。<br />
  对 <span class="math inline">\(a_{i}-b_{i}\)</span> 排序, 获得用 <span
class="math inline">\(i\)</span> 个红胡椒与 <span
class="math inline">\(N-i\)</span> 个黑胡椒的最大美味值, 记为 <span
class="math inline">\(v_{i}\)</span>。<br />
  接下来对每对 <span class="math inline">\(x_{j}, y_{j}\)</span> 做
<span class="math inline">\(exgcd\)</span> , 先判断是否有解,
在记录有解情况下红胡椒/黑胡椒最少需要的<strong>份数</strong> ,
再判断一次是否有解, 然后去做三分, 因为答案 <span
class="math inline">\(v_{ans}\)</span> 一定单峰。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1728/E">link</a> ,
注释都在里面了, 不贴了</p>
<h3 id="f-9"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728/problem/F">F</a></h3>
<p>题意：<br />
(来自官方题解) 给定 <span class="math inline">\(a\)</span> 数组, 长度为
<span class="math inline">\(n\)</span> , 确定每个 <span
class="math inline">\(b_{i}\)</span> 的值, 使得 <span
class="math inline">\(a_{i}|b_{i}\)</span> , 所有 <span
class="math inline">\(b_{i}\)</span> 不同, 且 <span
class="math inline">\(\sum b_{i}\)</span> 最小。<span
class="math inline">\(n \leq 1000, 1 \leq a_{i} \leq 10^6\)</span>
。<br />
思路：<br />
(来自官方题解) 根据鸽笼原理, 对于每个 <span
class="math inline">\(a_{i}\)</span> , 只要考虑 <span
class="math inline">\(1*a_{i}, 2*a_{i}, 3*a_{i}, ..., n*a_{i}\)</span>
这几个 <span class="math inline">\(b_{i}\)</span> 值,
问题可以转化为二分图最优匹配, 跑费用流的复杂度为 <span
class="math inline">\(O(n^4)\)</span> , 寄定了,
注意到全职在点上而不在边上, 我们就可以跑传统二分图。<br />
  具体来说, 我们的左侧点是从小到大排列的 <span
class="math inline">\(b_{i}\)</span> 集合, 右侧点是对应的 <span
class="math inline">\(a_{i}\)</span> , 这样我们便可以保证答案的最小性,
然而复杂度还是 <span class="math inline">\(O(n^4)\)</span>
(左侧点决定主要复杂度, 太大了)。 一个优化是：不重置 <span
class="math inline">\(vis\)</span> 数组, 如果没有找到增广路,
它可以把复杂度优化到 <span class="math inline">\(O(M(E+V))\)</span> , M
为最大匹配的大小, 这样复杂度便为 <span
class="math inline">\(O(n^3)\)</span> 。<br />
代码：(来自本人) <a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728/submission/171595577">link</a></p>
<h3 id="g"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1728/problem/G">G</a></h3>
<p>状压 DP + 数学, 爷不会！</p>
<h2 id="codeforces-round-821-div2-22919"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1733">Codeforces round 821 (#Div2)
22/9/19</a></h2>
<p><span class="math inline">\((1675\rightarrow1735,
rk592)\)</span><br />
糊出来 D1, 但糊不出 D2, 算了, 能上小分就不错了……</p>
<h3 id="d2-3"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1733/problem/D2">D2</a></h3>
<p>题意：<br />
  给定三个数 <span class="math inline">\(n, x, y\)</span> , 其中 <span
class="math inline">\(5 \leq n \leq 5000\)</span> , 再给定两个长度为
<span class="math inline">\(n\)</span> 的 01数组 <span
class="math inline">\(a, b\)</span> 。 你每次可以选择 <span
class="math inline">\(a\)</span> 中的两个位置, 让它们都异或 <span
class="math inline">\(1\)</span> , 若选择的位置相邻, 代价为 <span
class="math inline">\(x\)</span> , 否则代价为 <span
class="math inline">\(y\)</span> , 输出 <span
class="math inline">\(a\)</span> 数组变为 <span
class="math inline">\(b\)</span> 数组的最小代价, 若不存在则输出 <span
class="math inline">\(-1\)</span> 。<br />
思路：<br />
  DP 是显然的, 注意到仅当 <span class="math inline">\(a, b\)</span>
不同的位数是偶数时有解, 两个位置 <span class="math inline">\(i,
j\)</span> 操作的代价为 <span
class="math inline">\(min(y,(j-i)*x)\)</span> , 当 <span
class="math inline">\(j-i=1\)</span> 时代价为 <span
class="math inline">\(min(2*y,x)\)</span> ,
因为我们可以找一个远一点的中转点进行两次操作来改变 <span
class="math inline">\(i,j\)</span> 位置的值 。<br />
  当 <span class="math inline">\(x \geq y\)</span> 时, 优先使用 <span
class="math inline">\(y\)</span> 代价的操作, 若不可避免的要使用 <span
class="math inline">\(x\)</span> 代价操作, 则取 <span
class="math inline">\(min(2*y,x)\)</span>。<br />
  当 <span class="math inline">\(x &lt; y\)</span> 时, 两个位置 <span
class="math inline">\(i, j\)</span> 操作的代价为 <span
class="math inline">\(min(y,(j-i)*x)\)</span> ,
此时没有上文的特例了。若在不相邻的一对位置上使用 <span
class="math inline">\(x\)</span> 操作一定更劣,
因为拆开来就能覆盖更多位置。所以我们从前往后枚举最后一个位置是否用 <span
class="math inline">\(x\)</span> 操作与前一个位置消除。<br />
设 <span class="math inline">\(f_{i}\)</span> 为前 <span
class="math inline">\(i\)</span> 个位置<strong>最小代价的两倍</strong>,
对于 <span class="math inline">\(i &gt; 2\)</span> ：<br />
<span
class="math display">\[f_{i}=min(f_{i-1}+y,f_{i-2}+2*x*(pos_{i}-pos_{i-1}))\]</span><br />
  其中 <span class="math inline">\(f_{1}=y,
f_{2}=min(2*y,2*x*(pos_{2}-pos_{1}))\)</span> ,
可以看出我们巧妙分拆了贡献, 对于奇数项, 不管与不与前一项消除,
身上总是带着一个 <span class="math inline">\(y\)</span> 的,
帮助了偶数项的转移。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1733/submission/172774308">link</a></p>
<h3 id="e-15"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1733/problem/E">E</a></h3>
<p>题意：<br />
  有一个 <span class="math inline">\(120*120\)</span> 大小的棋盘,
左上角位置为 <span class="math inline">\((0,0)\)</span> ,
每格上有一个传送带, 初始方向全部朝右, 从 <span
class="math inline">\(0\)</span> 时刻开始会发生：<br />
1、每一秒在 <span class="math inline">\(0,0\)</span> 放下一个球。<br />
2、如果 <span class="math inline">\((i,j)\)</span> 存在一个球,
则它会移动到 <span class="math inline">\((i,j)\)</span>
传送带的下一个位置; 如果某个位置存在多个球, 则合并为一个;
如果下一个位置超出棋盘, 则丢弃。<br />
3、每传送一次球, 传送带的方向就会变化; 原来向右变向下,
原来向下变向右。<br />
  1e4 次询问, 问第 <span class="math inline">\(t(t \leq
10^{18})\)</span> 秒时, <span class="math inline">\((i,j)\)</span>
是否有球, codeforces 原题链接里还有个图片流程示例, 就不贴了。<br />
思路：<br />
  找规律/递推, 一个重要的性质是, 假设经过某个位置有 <span
class="math inline">\(n\)</span> 个球, 则被传到右边的球数为 <span
class="math inline">\(\lceil \frac{n}{2} \rceil\)</span> ,
被传送到左边的球数为 <span class="math inline">\(\lfloor \frac{n}{2}
\rfloor\)</span> , 考虑通过差分前缀和算出第 <span
class="math inline">\(t\)</span> 秒是否有球经过, 设 <span
class="math inline">\(f_{t,x,y}\)</span> 为到第 <span
class="math inline">\(t\)</span> 秒<strong>为止</strong>时经过 <span
class="math inline">\((x,y)\)</span> 点的球的总数, 若 <span
class="math inline">\(f_{t,x,y} \neq f_{t-1,x,y}\)</span> 说明第 <span
class="math inline">\(t\)</span> 秒有球经过。<br />
  在具体操作中, 去除 <span class="math inline">\(t\)</span> 维, <span
class="math inline">\(f_{0,0}=max(0,t-x-y+1)\)</span>, <span
class="math inline">\((f_{i,j}+1)/2 \rightarrow f_{i,j+1},\;f_{i,j}/2
\rightarrow f_{i+1,j}\)</span> 推一下就行了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1733/submission/172776699">link</a><br />
不是很理解这个 <span class="math inline">\(memset\)</span> 复杂度 * 1e4
询问量 怎么过的掉……</p>
<h2 id="codeforces-round-822-div2-22923"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1734">Codeforces Round 822 (#Div2)
22/9/23</a></h2>
<p><span class="math inline">\((1735\rightarrow1792,
rk475)\)</span><br />
构造, 一生之敌……构造 + E题 = 含恨离场。<br />
但还是上分了, 好耶。</p>
<h3 id="e-16"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1734/problem/E">E</a></h3>
<p>题意：<br />
  初始给定一个 <span class="math inline">\(b\)</span> 数组, 构造一个
<span class="math inline">\(n * n\)</span> 矩阵 <span
class="math inline">\(a\)</span> , 保证 <span
class="math inline">\(n\)</span> 为质数, 满足以下条件：<br />
1、<span class="math inline">\(a_{i,i}=b_{i}, \;\forall \;0 \leq b_{i}
&lt;n\)</span><br />
2、<span class="math inline">\(a_{r1,c1}+a_{r2,c2}\not\equiv
a_{r1,c2}+a_{r2,c1} \; (mod\;n), \;\forall \;1\leq r_{1}&lt;r_{2}\leq n,
1 \leq c_{1} &lt; c_{2} \leq n, 0 \leq a_{i,j} &lt; n\)</span><br />
思路：<br />
转化式子, 第二个约束条件等价于：<br />
<span class="math display">\[a_{r1,c1}-a_{r1,c2}\not\equiv
a_{r2,c1}-a_{r2,c2} \;(mod\;n)\]</span>
于是我们只要让每一行为公差不同的等差数列即可, 公差为 <span
class="math inline">\([0,n-1]\)</span>。<br />
现在考虑第一个性质, 要满足角标元素, 可以这么构造：<br />
<span class="math display">\[a_{i,j}=(i*(j-i+n)+b_{i})\]</span><br />
这样子 <span class="math inline">\(i\)</span> 承担了公差的使命, <span
class="math inline">\(i=j\)</span> 时 <span
class="math inline">\(a_{i,j} \; mod \; n =b_{i}\)</span> , 后面加个
<span class="math inline">\(n\)</span> 防止取模取出负数。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1734/submission/173267697">link</a><br />
  官方题解更厉害, 直接给出了构造的通用<a
target="_blank" rel="noopener" href="https://codeforces.com/blog/entry/107231">二次多项式</a>……,
这题构造方法极多, 场上一个没想出来有点离谱。</p>
<h3 id="f-10"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1734/problem/F">F</a></h3>
<p>题意：<br />
  给你一个无限长度的 <span
class="math inline">\(\tt{Thue-Morse\;sequence}\)</span>,
通过如下方式构造, 初始字符串 <span class="math inline">\(s = 0\)</span>
, 接下来无限步中, <span class="math inline">\(s=s\;+\; inv(s)\)</span> ,
其中 <span class="math inline">\(inv(s)\)</span> 为 <span
class="math inline">\(s\)</span> 按位取反得到的字符串, <span
class="math inline">\(\bf Example: 0
\;01\;0110\;01101001\;0110100110010110\;...\)</span>。<br />
给定两个数 <span class="math inline">\(n, m \leq 1e18\)</span> , 问
<span class="math inline">\(s\)</span> 长度为 <span
class="math inline">\(m\)</span> 的两个子串 <span
class="math inline">\(s[0,m-1], s[n,n+m-1]\)</span> 有多少处不同？<br />
思路：<br />
  二进制考虑手玩一些性质, 我将每个数对应它们的二进制下标可以发现：下标中
<span class="math inline">\(1\)</span> 的数目为奇数, 对应数位为 <span
class="math inline">\(1\)</span> , 下标中 <span
class="math inline">\(1\)</span> 的数目为偶数, 对应数位为 <span
class="math inline">\(0\)</span> 。换言之, <span
class="math inline">\(s[i]=\_\_builtin\_parity(i)\)</span> , 效率是
<span class="math inline">\(O(n)\)</span> 的, 显然不够, 我们要找一种只带
<span class="math inline">\(log\)</span> 的做法 ,
想到这里我就寄了去看题解。<br />
  考虑递归推式子, 我们简记 <span
class="math inline">\(\_\_builtin\_parity(i)=par(i)\)</span> , 问题是求
<span class="math inline">\(f(n,m)=\sum\limits_{i=0}^{m-1}{[par(i) \neq
par(n+i)]}\)</span> , 当 <span class="math inline">\(m=0\)</span> 时,
<span class="math inline">\(f(n,m)=0\)</span> , 当 <span
class="math inline">\(m=1\)</span> 时, <span
class="math inline">\(f(n,m)=[par(0) \neq
par(n)]=par(n)\)</span>。<br />
  为了方便讨论, 我们可以固定 <span class="math inline">\(m\)</span>
的奇偶性, 让我们固定 <span class="math inline">\(m\)</span> 为偶数,
因为这样可以方便递归, 在 <span class="math inline">\(m\)</span>
为奇数时拆出最后一项, <span
class="math inline">\(f(n,m)=f(n,m-1)+[par(m-1) \neq
par(n+m-1)]\)</span> 就可以了; 接下来我们分类讨论 <span
class="math inline">\(n\)</span> 的奇偶性, 若 <span
class="math inline">\(n\)</span> 为偶数, 观察 <span
class="math inline">\(par()\)</span> 的特性, 因为 <span
class="math inline">\(par(2k) \neq par(2k+1)\)</span> , 同理 <span
class="math inline">\(par(2k+n) \neq par(2k+n+1)\)</span> ,
所以有恒等式：<br />
<span class="math display">\[[par(2k) \neq par(n+2k)]=[par(2k+1) \neq
par(n+2k+1)]\]</span><br />
成立, 设 <span class="math inline">\(2k=i\)</span> , 发现又变为了 <span
class="math inline">\([par(i) \neq par(n+i)]\)</span> 的形式,
所以有：<br />
<span class="math display">\[
\begin{aligned}
f(n,m) &amp;= \sum\limits_{i=0}^{m-1}{[par(i) \neq par(n+i)]}\\
&amp;=2 \sum\limits_{k=0}^{m/2-1}{[par(2k) \neq par(n+2k)]}\\
&amp;=2 \sum\limits_{i=0}^{m/2-1}{[par(i) \neq par(n/2+i)]}\\
&amp;=2* f(n/2,m/2)
\end{aligned}
\]</span> 若 <span class="math inline">\(n\)</span> 为奇数,
同理有恒等式： <span class="math display">\[[par(2k) \neq
par(n+2k)]=[par(2k) = par(n+2k-1)]\]</span><br />
注意这里是 <span class="math inline">\(-1\)</span> 而不是 <span
class="math inline">\(+1\)</span> ,
奇数保证能与它前面的偶数二进制位相反,
与后面的偶数的二进制位关系则是不确定的, 同理还有： <span
class="math display">\[[par(2k+1) \neq
par(n+2k+1)]=[par(2k)=par(n+2k+1)]\]</span><br />
所以我们可以把 <span class="math inline">\(2k, 2k+1\)</span> 都转为
<span class="math inline">\(2k\)</span> 然后向下递归。<br />
<span class="math display">\[
\begin{aligned}
f(n,m) &amp;= \sum\limits_{i=0}^{m-1}{[par(i) \neq par(n+i)]}\\
&amp;= \sum\limits_{k=0}^{m/2-1}{\Big([par(2k) \neq
par(n+2k)]\;+\;[par(2k+1) \neq par(n+2k+1)]}\Big)\\
&amp;= \sum\limits_{k=0}^{m/2-1}{\Big([par(2k) =
par(n+2k-1)]\;+\;[par(2k) = par(n+2k+1)]}\Big)\\
&amp;= \sum\limits_{i=0}^{m/2-1}{\Big([par(i) =
par((n-1)/2+i)]\;+\;[par(i) = par((n+1)/2+i)]}\Big)\\
&amp;=m\;-\;f((n-1)/2,m/2)\;-\;f((n+1)/2,m/2)
\end{aligned}
\]</span> 最后一行因为不等号变等号进行了容斥。<br />
状态数为 <span class="math inline">\(O(log\;n\;log\;m)\)</span> ,
进行记忆化搜索即可。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; PII;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> T, N, M;</span><br><span class="line">map&lt;PII,<span class="type">int</span>&gt; mp;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">par</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;<span class="keyword">return</span> __builtin_parityll(x);&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(m==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">par</span>(n);</span><br><span class="line">	<span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">f</span>(n,m<span class="number">-1</span>)+(<span class="built_in">par</span>(m<span class="number">-1</span>)!=<span class="built_in">par</span>(n+m<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">if</span>(mp.<span class="built_in">count</span>(<span class="built_in">make_pair</span>(n,m))) <span class="keyword">return</span> mp[<span class="built_in">make_pair</span>(n,m)];</span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) ans=<span class="number">2</span>*<span class="built_in">f</span>(n/<span class="number">2</span>,m/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">else</span> ans=m-<span class="built_in">f</span>((n<span class="number">-1</span>)/<span class="number">2</span>,m/<span class="number">2</span>)-<span class="built_in">f</span>((n+<span class="number">1</span>)/<span class="number">2</span>,m/<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> mp[<span class="built_in">make_pair</span>(n,m)]=ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	cin &gt;&gt; T;</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		cin &gt;&gt; N &gt;&gt; M;</span><br><span class="line">		mp.<span class="built_in">clear</span>();</span><br><span class="line">		cout &lt;&lt; <span class="built_in">f</span>(N,M) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <span
class="math inline">\(\mathcal{ELEGANT}\)</span><br />
有好想但难写的正统数位 DP 做法, 可能以后更新。</p>
<h2 id="codeforces-round-823-div2-22925"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730">Codeforces Round 823 (#Div2)
22/9/25</a></h2>
<p><span class="math inline">\((1792\rightarrow1672,
rk4583)\)</span><br />
只会 AB, 一把掉干, 但是心态又比上次进步了许多......, B
题就糊了个三分上去就离谱, C 题简单字符串上贪心没调出来,
我想这也是算法竞赛的一部分, 不爽不要玩……<br />
然而我还得玩, 在度过糟糕的一晚后过来补题了……</p>
<h3 id="c-2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/problem/C">C</a></h3>
<p>题意：<br />
  <span class="math inline">\(0\)</span> 到 <span
class="math inline">\(9\)</span> 组成的字符串 <span
class="math inline">\(s\)</span> , 你可以随时取出一位数字 <span
class="math inline">\(d\)</span> , 再插入 <span
class="math inline">\(min(d+1,9)\)</span> 到任意位置,
问你能得到的字典序最小字符串。<br />
思路：<br />
  从后往前更新, 因为要把字典序小的甩到前面,
大的放到后面去。动态更新最小值, 将大于最小值的全部甩到后面就行了。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">string s; </span><br><span class="line">cin &gt;&gt; s; </span><br><span class="line"><span class="type">int</span> cnt[<span class="number">10</span>]=&#123;&#125;;</span><br><span class="line"><span class="type">int</span> x=<span class="number">9</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=s.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">	<span class="keyword">if</span>(s[i]-<span class="string">&#x27;0&#x27;</span>&lt;=x)&#123;</span><br><span class="line">		x=s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		cnt[s[i]-<span class="string">&#x27;0&#x27;</span>]++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> cnt[<span class="built_in">min</span>(s[i]-<span class="string">&#x27;0&#x27;</span>+<span class="number">1</span>,<span class="number">9</span>)]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++) cout &lt;&lt; <span class="built_in">string</span>(cnt[i],<span class="string">&#x27;0&#x27;</span>+i); <span class="comment">// cnt[i] 个 &#x27;0&#x27;+i 字符 </span></span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="d-11"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/problem/D">D</a></h3>
<p>题意：<br />
  两个只包含小写英文字母且长度为 <span class="math inline">\(n(n \leq
1e5)\)</span> 的字符串 <span class="math inline">\(s_{1}, s_{2}\)</span>
, 你每次可以交换长度为 <span class="math inline">\(k(1 \leq k \leq
n)\)</span> 的 <span class="math inline">\(s_{1}\)</span> 的前缀与 <span
class="math inline">\(s_{2}\)</span> 的后缀, 问是否能使得 <span
class="math inline">\(s_{1}=s_{2}\)</span> ?<br />
思路：<br />
  观察每次我们所做的：交换 <span
class="math inline">\(s_{1}[1...i]\)</span> 与 <span
class="math inline">\(s_{2}[n+1-i...n]\)</span> , <span
class="math inline">\(s_{1}[i]\)</span> 与 <span
class="math inline">\(s_{2}[n+1-i]\)</span> 不可能处于同一个串中,
且始终对称。<br />
  接下来一个可以手玩出的结论是：对于一对 <span
class="math inline">\(s_{1}[i],s_{2}[n+1-i]\)</span>
可以在保证它们对称的前提下随意调整它们的位置。一种构造是, 设 <span
class="math inline">\(op(k)\)</span> 为一次操作, 交换长度为 <span
class="math inline">\(k\)</span> 的 <span
class="math inline">\(s_{1}\)</span> 的前缀与 <span
class="math inline">\(s_{2}\)</span> 的后缀, 一次 <span
class="math inline">\(op(k)\)</span> , 一次 <span
class="math inline">\(op(k+1)\)</span> 可以视为一组操作, 在 <span
class="math inline">\(s_{1}, s_{2}\)</span> 的前 <span
class="math inline">\(k+1\)</span> 位上轮换,
最终我们都能调整字符对到我们想要的位置, 只要从大到小轮换就可以了。<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/6inkxpj4.png" /><br />
<del>Windows画图好难受</del><br />
所以, 能使得 <span class="math inline">\(s_{1}=s_{2}\)</span> ,
当且仅当对于所有对称字符对<span class="math inline">\((a,b)(a \leq
b)\)</span> ：<br />
1、<span class="math inline">\(a \neq b\)</span> , <span
class="math inline">\((a,b)\)</span> 的出现次数是偶数(<span
class="math inline">\(s_{1}[i]=s_{2}[n+1-i], \;
s_{1}[n+1-i]=s_{2}[i]\)</span>)<br />
2、<span class="math inline">\(a = b\)</span> , 仅在 <span
class="math inline">\(n\)</span> 为奇数时最多出现一对出现次数为奇数的
<span class="math inline">\((a,b)\)</span> , 可以安插在中间(事实上……
<span class="math inline">\(n\)</span> 不用判奇偶……想想为什么)。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/submission/173529525">link</a></p>
<h3 id="e-17"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/problem/E">E</a></h3>
<p>题意：<br />
给你长度为 <span class="math inline">\(n(n \leq 5e5)\)</span> 的数组
<span class="math inline">\(a(a_{i} \leq 1e6)\)</span> ,
问你有多少段区间 <span class="math inline">\([l,r]\)</span> 满足 <span
class="math inline">\(min\{a_{l...r}\}|max\{a_{l...r}\}\)</span>
。<br />
思路：<br />
  值域这么小能不能用一用啊……好像不行……是用来分解质因数的……<br />
  区间的选择有 <span class="math inline">\(n^2\)</span> 种,
区间最大值的选择只有 <span class="math inline">\(n\)</span> 种,
这句话来自 codeforces exercises 1 的第一场比赛的第一篇题解,
现在又用上了。<br />
  让我们同理处理 <span class="math inline">\(a_{i}\)</span> 左边/右边
第一位比它 大/小 的数字的下标, 记为 <span
class="math inline">\(rmax_{i}, rmin_{i}, lmax_{i}, lmin_{i}\)</span>,
其中 <span class="math inline">\(lmax_{i}\)</span>
<strong>特殊定义为</strong>左边第一位<strong>大于等于</strong> <span
class="math inline">\(a_{i}\)</span> 的数的下标, 当：<br />
<span class="math display">\[lmax_{i} &lt; l \leq i \;\;\&amp;\&amp;\;\;
i \leq r &lt; rmax_{i} \;\;(1)\]</span><br />
时, <span class="math inline">\(a_{i}=max\{a_{l...r}\}\)</span> , 在
<span class="math inline">\((1)\)</span> 的前提下, 我们枚举 <span
class="math inline">\(a_{i}\)</span> 的除数 <span
class="math inline">\(j\)</span> 作为最小值, 设左边离 <span
class="math inline">\(i\)</span> 最近的最小值为 <span
class="math inline">\(j_{1}\)</span> , 要满足：<br />
<span class="math display">\[lmax_{i} &lt; l \leq pos_{j_{1}}
\;\;\&amp;\&amp;\;\; pos_{j_{1}} &lt; i \;\;\&amp;\&amp;\;\; i &lt;
rmin_{pos_{j_{1}}}\]</span><br />
设右边离 <span class="math inline">\(i\)</span> 最近的为 <span
class="math inline">\(j_{2}\)</span> , 也同理,<br />
<span class="math display">\[pos_{j_{2}} \leq r &lt; rmax_{i}
\;\;\&amp;\&amp;\;\; pos_{j_{2}} \geq i \;\;\&amp;\&amp;\;\; i &gt;
lmin_{pos_{j_{2}}}\]</span> 最难理解的部分是去除重复统计的区间,
官方题解简直是谜语人附体, 思路是这样的, 枚举 <span
class="math inline">\(j_{1}\)</span> 的区间可以包含 <span
class="math inline">\(j_{2}\)</span> , 枚举 <span
class="math inline">\(j_{2}\)</span> 的区间时不能包含 <span
class="math inline">\(j_{1}\)</span> , 如果只有 <span
class="math inline">\(j_{1}\)</span> 或只有 <span
class="math inline">\(j_{2}\)</span> 照常枚举, 如果 <span
class="math inline">\(ar_{i}=j_{1}\)</span> 那么实际上是 <span
class="math inline">\(ar_{i}=j_{2}, j_{1}=ar_{i}\)</span> 因为无法满足
<span class="math inline">\(lmax_{i} &lt; l \leq pos_{j_{1}}\)</span> ,
这也是定义 <span class="math inline">\(lmax_{i}\)</span>
时要取等号的原因, 你也可以不在 <span class="math inline">\(lmax\)</span>
上取等号而在 <span class="math inline">\(rmax\)</span> 上取等号,
效果是一样的......<br />
  然后统计区间的个数, 加一加就行了, 复杂度 O(能过), 因为有 5s。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/submission/173547567">link</a>,
里面也有一些注释……具体实现要枚举因子, 储存 <span
class="math inline">\(pos\)</span> 与下一个下标 <span
class="math inline">\(idx\)</span> , 单调栈处理 <span
class="math inline">\(lmax,lmin,rmax,rmin\)</span> 等等......</p>
<h3 id="f-11"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/problem/F">F</a></h3>
<p>咕~</p>
<h2 id="educational-codeforces-round-136-div2-22929"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739">Educational Codeforces Round
136 (#Div2) 22/9/29</a></h2>
<p><span class="math inline">\((1672\rightarrow1578,
rk4496)\)</span><br />
继续下分, 好耶, specialist again!<br />
早上起来发现自己 B 被 hack 了……讨厌 edu round,
只算题数不算分数导致我掉到了 4000 多名……D 是个二分还做不出来,
因此我们应该 "Stop learning useless algorithms......"</p>
<h3 id="d-12"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739/problem/D">D</a></h3>
<p>题意：<br />
  给定一颗以 <span class="math inline">\(1\)</span> 为根节点的树,
每次操作可以移植一颗子树到根的下部, 问 <span
class="math inline">\(k\)</span> 次操作后最大深度的最小值。<br />
思路：<br />
  二分这个最大深度, 从树的底部向上更新,
若一段长度大于等于这个最大深度就接到根节点上去,
注意根节点与根节点的子节点不更新。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739/submission/174030239">link</a></p>
<h3 id="e-18"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739/problem/E">E</a></h3>
<p>题意：<br />
  给你一个 <span class="math inline">\(2* n\)</span> 的矩阵, 一些格子是
"脏" 的, 另一些是干净的, 分别用 <span class="math inline">\(1,0\)</span>
表示。机器人从 <span class="math inline">\((1,1)\)</span>
开始清理脏格子, 每次朝离它最近的脏格子移动,
若在任意时刻离它最近的脏格子有多个就会停机,
问存在机器人不停机且清理完脏格子所需要预先移除的最少的脏格子数量, <span
class="math inline">\(n \leq 2e5\)</span> 。<br />
思路：<br />
  显然这题没有这么显然。<br />
  后面的格子会隐隐对前面的格子形成控制之势, 如图：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/n5pos5mc.png" /><br />
考虑倒推, 设 <span class="math inline">\(f_{i,j}\)</span> 表示机器人从
<span class="math inline">\((i,j)\)</span>
出发需要预先移除的最少的垃圾数量, 进行分类讨论, 设当前在处理 <span
class="math inline">\(f_{i,j}\)</span>。<br />
下文的转移建立在<strong>它本身条件以及上文条件</strong>的基础上：<br />
1、<span class="math inline">\(f_{i \oplus 1, j}=0\)</span> ,
此时最近的就是下一列的脏格子, 本列已经处理完毕, 转移为 <span
class="math inline">\(f_{i,j}=f_{i+1,j}\)</span> 。<br />
2、<span class="math inline">\(f_{i+1,j}=0\)</span> ,
此时下一列对应行没有脏格子, 我们可以直接过去并移除本列的脏格子,
也可以从另一行绕过去, 转移为 <span
class="math inline">\(f_{i,j}=min(f_{i+1,j}+1,f_{i+1,j \oplus
1})\)</span><br />
3、<span class="math inline">\(f_{i+1,j \oplus 1}=0\)</span> ,
此时状态是这样的：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/b3ux46i0.png" /><br />
可以看到小机器人已经被包围了！我们必须去掉一个脏格子,
同时我们转移到两列后而不是一列后, 因为我们已经规定了下一列的状态,
转移为：<span class="math inline">\(f_{i,j}=min(f_{i+2,j}+1,f_{i+2,j
\oplus 1}+1)\)</span> 。<br />
4、<span class="math inline">\(f_{i+1,j \oplus 1}=1\)</span> ,
此时状态是这样的：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/d7dpphp0.png" /><br />
要么移除下面两个, 从上面走, 要么移除上面一个, 从下面走, 转移为：<span
class="math inline">\(f_{i,j}=min(f_{i+2,j}+2,f_{i+2,j \oplus
1}+1)\)</span> 。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739/submission/174048203">link</a>
很短很好懂。</p>
<h3 id="f-12"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1739/problem/F">F</a></h3>
<p>于 22.11.18 7:30~15:00 补题, 因为处理字符串的失误调的上头,
中间听完了四五遍 toe 的专, 很好的平复了情绪, 进行一个无关的推荐。<br />
题意：<br />
(字符集大小为 12, 即前 12 个英文字母)<br />
有 <span class="math inline">\(n \leq 1000\)</span> 个单词,
每个单词的相邻字符不相同, 每个单词有一个权值 <span
class="math inline">\(c \leq 1e5\)</span>, 每个单词长为 <span
class="math inline">\(s \geq 2\)</span> , 保证 <span
class="math inline">\(\sum s \leq 2000\)</span>。<br />
你要设计一个长度为十二的数组作为键盘, 使每一位对应字符集的一个字符,
不重不漏。若一个单词所有相邻的两个字母在键盘上也相邻,
你可以得到单词所对应的权值(称为单词能在键盘上被简单输出),
请输出一种获得最大权值和的数组构造方案。<br />
思路：<br />
我们可以把每个单词想象成最多只有十二个节点的无向图,
单词中每两个相邻的字符代表无向图中的一条边。 显然有一些 “图”
的权值我们不可能得到, 例如在图上有环的时候或者这个图有一些点的度 <span
class="math inline">\(\geq\)</span> 3 的时候。<br />
如果一个单词能在键盘上被简单输出, 例如 "abcb" , 它对应的无向图为 a-b-c ,
实际上是一条链, 这个链在键盘上可能会有两种排列：abc 与 cba。<br />
我们把所有合法的链的两种排列对应的字符串拉去建立AC自动机,
在每个单词末尾加入权值 <span
class="math inline">\((t[u].v+=val)\)</span> ,
每个节点顺便也加上它对应的 fail 子树上所有节点的权值, 这个在连 fail
边时可以顺便进行, 因为如果一个单词在某个节点完成匹配, 它的 fail
边连接的是这个节点所代表单词的最长后缀, 一定也完成了匹配。<br />
我们的目标是找到一个 <span class="math inline">\(a-l\)</span> 的排列,
我们可以用状压DP的思想来做这个, 设计 <span
class="math inline">\(f[s][i]\)</span> 表示当前选取的字符集和状态为
<span class="math inline">\(s\)</span> , 当前处于 trie 图上的 <span
class="math inline">\(i\)</span> 号节点时能得到的最大权值和, 转移 <span
class="math inline">\(f[s][i]\)</span> 需要在最外层枚举状态 <span
class="math inline">\(s\)</span> , 内层枚举当前节点 <span
class="math inline">\(i\)</span> , 最内层再枚举当前节点的子节点,
复杂度为 <span class="math inline">\(2^{12} * 2^{12} * 12\)</span>
但因为跑不满 + 4s 时限所以还是可行的。<br />
对于每个状态为 <span class="math inline">\(s\)</span> 的可行节点 <span
class="math inline">\(u\)</span>, 当我们枚举到它的 <span
class="math inline">\(j\)</span> 号儿子时的转移方程为：<br />
<span class="math display">\[ f[s \oplus 2^j][t[u].s[j]]=max(f[s \oplus
2^j][t[u].s[j]], f[s][u]+t[s \oplus 2^j].v)\]</span><br />
我们处理出来最大值, 然后随便选一个等于最大值的 <span
class="math inline">\(f[2^{12}-1][i]\)</span> ,
再逆着它回溯就能找到一种可能的键盘布局了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/submission/1739/181383574">link</a><br />
细节很多, 你不妨想想怎么把一条链对应的两个字符串拉出来, 然而我写的这一切
<span class="math inline">\(\color{black}{j}\color{red}{iangly}\)</span>
十九分钟就写完了, 而我得用 190 行加上五六个小时。</p>
<h2 id="codeforces-global-round-22-22930"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738">Codeforces Global Round 22
22/9/30</a></h2>
<p><span class="math inline">\((1578\rightarrow1531,
rk3457)\)</span><br />
……<br />
来看题……</p>
<h3 id="c-3"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1730/problem/C">C</a></h3>
<p>题意：<br />
  一个数组, Alice 和 Bob 轮流拿数, Alice 先手, 最后 Alice
拿到的数之和为偶数则 Alice 赢, 问在双方最优情况下谁赢。<br />
思路：<br />
分类讨论, 设奇数个数为 <span class="math inline">\(x\)</span> ,
偶数个数为 <span class="math inline">\(y\)</span> , 则：<br />
1、<span class="math inline">\(x \; mod \; 4=0\)</span> , Alice 必胜,
可以保证 Alice 拿到一半的奇数。<br />
2、<span class="math inline">\(x \; mod \; 4=1, y \; mod \; 2=0\)</span>
, Alice 必败, Bob 跟着 Alice 拿, 可以保证 Alice 拿到奇数个奇数。<br />
3、<span class="math inline">\(x \; mod \; 4=1, y \; mod \; 2=1\)</span>
, Alice 可以保证让 Bob 拿到第一个奇数, 从而拿到偶数个奇数。<br />
4、<span class="math inline">\(x \; mod \; 4=2\)</span> , Alice 必败,
Bob 可以保证 Alice 拿到奇数个奇数。<br />
5、<span class="math inline">\(x \; mod \; 4=3\)</span> , Alice 必胜,
Alice 先拿一个奇数, 此时转化为上一种情况, Alice 可以保证 Bob
拿到奇数个奇数, 从而自己拿到偶数个奇数。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/submission/174916999">link</a></p>
<h3 id="d-13"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/problem/D">D</a></h3>
<p>题意：<br />
  对于一个排列 <span
class="math inline">\(a_{1},a_{2},...,a_{n}\)</span> , 以及一个整数
<span class="math inline">\(k(0 \leq k \leq n)\)</span> ,
以如下的方式计算 <span class="math inline">\(b\)</span> 数组:<br />
$; i , x=a_{i}, $<br />
1、<span class="math inline">\(x \leq k\)</span> , 设置 <span
class="math inline">\(b_{x}\)</span> 为满足 <span
class="math inline">\(1 \leq j &lt; i \;\;\&amp;\&amp;\;\; a_{j} &gt;
k\)</span> 的最后一个 <span class="math inline">\(a_{j}
(b_{a_{i}}=a_{j})\)</span> , 若不存在这样的 <span
class="math inline">\(j\)</span>, <span
class="math inline">\(b_{x}=n+1\)</span><br />
2、<span class="math inline">\(x &gt; k\)</span> , 设置 <span
class="math inline">\(b_{x}\)</span> 为满足 <span
class="math inline">\(1 \leq j &lt; i \;\;\&amp;\&amp;\;\; a_{j} \leq
k\)</span> 的最后一个 <span class="math inline">\(a_{j}
(b_{a_{i}}=a_{j})\)</span> , 若不存在这样的 <span
class="math inline">\(j\)</span> , <span
class="math inline">\(b_{x}=0\)</span><br />
给定 <span class="math inline">\(b\)</span> 数组, 让你求一个满足条件的
<span class="math inline">\(a\)</span> 数组与 <span
class="math inline">\(k\)</span> , 题目保证存在。<br />
思路：<br />
  做 permutation 题, 关键是看出它的操作到底想干什么,
不要被下标套娃绕晕了, 例如这题如何求 <span
class="math inline">\(k\)</span> ? 观察到它把下标 <span
class="math inline">\(\leq k\)</span> 的数变为 <span
class="math inline">\(&gt; k\)</span> 的数, 我们只要统计 <span
class="math inline">\(b_{i}&gt;i\)</span> 的数目便可求出 <span
class="math inline">\(k\)</span> ,
不用跟我开始一样顺着排列黑白染色……。<br />
  接下来开始不断手玩样例, 可以发现一个结论: <span
class="math inline">\(b_{a_{l}}=b_{a_{r}}\)</span> , <span
class="math inline">\(\forall t \in [l,r], b_{a_{t}}=b_{a_{l}}\)</span>
。用人话来讲, <span class="math inline">\(b\)</span>
数组中值相同的位置处于 <span class="math inline">\(a\)</span>
数组中连续的一段。<br />
  对于样例 7 7 7 3 3 3 的答案是: k=3, a=1 2 3 4 5 6, 在这里 <span
class="math inline">\(a\)</span> 中的 1&amp;2 可以互换, 4&amp;5&amp;6
也可以互换, 在连续的一段中仅存在最后的 3 不能移动, 因为它推导了 <span
class="math inline">\(b\)</span> 数组剩下的部分。<br />
  我们每次显然可以先确定 <span class="math inline">\(b\)</span> 数组中
<span class="math inline">\(0\)</span> 和 <span
class="math inline">\(n+1\)</span> 所对应的位置, 我们可以将 <span
class="math inline">\(b\)</span> 数组放到一个 <span
class="math inline">\([0,n+1]\)</span> 的桶中,
寻找唯一的"推导数"再往后推导, 最后构造出整个 <span
class="math inline">\(a\)</span> 数组。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">N=<span class="built_in">read</span>(); a.<span class="built_in">clear</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=N+<span class="number">1</span>;i++) v[i].<span class="built_in">clear</span>();</span><br><span class="line"><span class="type">int</span> n1=<span class="number">0</span>, now=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">	br[i]=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">if</span>(br[i]&gt;i) n1++;</span><br><span class="line">	v[br[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v[N+<span class="number">1</span>].<span class="built_in">size</span>()) now=N+<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt&lt;=N)&#123;</span><br><span class="line">	cnt+=v[now].<span class="built_in">size</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;u:v[now])&#123;</span><br><span class="line">		<span class="keyword">if</span>(v[u].<span class="built_in">size</span>())</span><br><span class="line">			<span class="built_in">swap</span>(u,v[now].<span class="built_in">back</span>()); <span class="comment">//把“推导数”放到最后</span></span><br><span class="line">	&#125;</span><br><span class="line">	a.<span class="built_in">insert</span>(a.<span class="built_in">end</span>(),v[now].<span class="built_in">begin</span>(),v[now].<span class="built_in">end</span>());</span><br><span class="line">	now=v[now].<span class="built_in">back</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; n1 &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> u:a) cout &lt;&lt; u &lt;&lt; <span class="string">&quot; &quot;</span>; cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="e-19"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/problem/E">E</a></h3>
<p>题意：<br />
给定一个非负整数数组 <span class="math inline">\(a\)</span> , 长度为
<span class="math inline">\(n(n \leq 1e5)\)</span> ,
计算有多少种分割使得分割后的每一段的和构成的数组是一个回文数组。<br />
思路：<br />
   <span class="math inline">\(0\)</span> 在里面搅屎。<br />
   没有 <span class="math inline">\(0\)</span> 很好做, 双指针弄一下,
找出所有对称的分割点组, 每组有选或不选之分, 弄一下就行了。具体而言, 设
<span class="math inline">\(f_{i,j}\)</span> 为子序列 <span
class="math inline">\([i,j]\)</span> 中切分的方案数, 假设 <span
class="math inline">\(x\)</span> 是最小的满足存在一个 <span
class="math inline">\([i,j]\)</span> 的后缀等于 <span
class="math inline">\(x\)</span> 的前缀的位置(<strong>值可以为
0</strong>), 设这个后缀的位置为 <span class="math inline">\(y\)</span> ,
则有 <span class="math inline">\(f_{i,j}=2 * f_{x,y}\)</span>。<br />
   现在考虑中间有 <span class="math inline">\(0\)</span> 的情况,
上文的假设不变, <span class="math inline">\(x\)</span>
<strong>后面</strong>第一个<strong>非 0 位置</strong>为 <span
class="math inline">\(l\)</span> , <span
class="math inline">\(y\)</span> <strong>前面</strong> 第一个非零位置为
<span class="math inline">\(r\)</span> , 我们便可以调整分割的位置,
或者多分割几刀构成几个对称的 <span class="math inline">\(0\)</span>
区间。<br />
设 <span class="math inline">\(len=min(l-x,y-r)\)</span> ,
我们可以在中间切 <span class="math inline">\([0,len]\)</span> 刀,
此时的转移为<span class="math display">\[f_{i,j}=
\sum\limits_{k=0}^{len}{l-x \choose k}{y-r \choose
k}  f_{x,y}\]</span><br />
然后我们递归求解这个问题。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/submission/175193494">link</a><br />
注意 <span class="math inline">\([x,y]\)</span> 中间全为 <span
class="math inline">\(0\)</span> 部分的特判。</p>
<h3 id="f-13"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/problem/F">F</a></h3>
<p>题意：<br />
交互题, 给你一个 <span class="math inline">\(n(n \leq 1000)\)</span>
的无向图, 告诉你每个点的度, 你要给每个点染色, 满足：<br />
1、同一个颜色的所有点在同一个联通块内。<br />
2、同一种颜色(<span class="math inline">\(c\)</span>)的所有点的度(<span
class="math inline">\(s_{c}\)</span>)之和<strong>小于等于点数的平方</strong>(<span
class="math inline">\(s_{c} \leq n_{c}^2\)</span>)。<br />
你可以做至多 <span class="math inline">\(n\)</span> 次询问,
每次询问一个点, 若当前询问是针对该点的第 <span
class="math inline">\(k\)</span> 次询问, 则回答该点连接的第 <span
class="math inline">\(k\)</span> 条边所连接的另一个顶点。
要求你最终给出一种染色方案, 保证存在这样的方案。<br />
思路：<br />
糊了个贪心上去, 只与正解差一个 <span
class="math inline">\(\tt{break}\)</span> , 不知是幸运还是不幸……<br />
直觉上讲肯定是从度数大的点开始询问, 设当前询问点为 <span
class="math inline">\(u\)</span> , 我们以这样的算法来 bfs：<br />
1、询问到的节点 <span class="math inline">\(v\)</span> 未被访问过,
我们把 <span class="math inline">\(v\)</span> 合并进 <span
class="math inline">\(u\)</span> 的联通块。<br />
2、询问到的节点 <span class="math inline">\(v\)</span> 被访问过, 我们把
<span class="math inline">\(u\)</span> 合并进 <span
class="math inline">\(v\)</span> 的联通块,
<strong>并break</strong><br />
下面我们证明这种贪心的正确性, 我们实际上在构建一个森林, 当 <span
class="math inline">\(u\)</span> 的所有节点都未被访问过时, 设 <span
class="math inline">\(u\)</span> 点的度为 <span
class="math inline">\(d_{u}\)</span> , 有 <span
class="math inline">\(s_{c} \leq d_{u}* (d_{u}+1) &lt; (d_{u}+1)^2 =
n_{c}^2\)</span> , 满足条件。<br />
当 <span class="math inline">\(u\)</span> 的某个连接点 <span
class="math inline">\(v\)</span> 访问过时, <span
class="math inline">\(v\)</span> 所在的块设为 <span
class="math inline">\(c&#39;\)</span> , 一定满足条件(<span
class="math inline">\(s_{c&#39;} \leq n_{c&#39;}^2\)</span>), 设 <span
class="math inline">\(v\)</span> 为 <span
class="math inline">\(u\)</span> 上第 <span
class="math inline">\(i\)</span> 个1遍历到的点, 将 <span
class="math inline">\(u\)</span> 与前 <span
class="math inline">\(i-1\)</span> 个点加入这个块, 此时总节点数为 <span
class="math inline">\(n_{c&#39;}+i\)</span> , 度数和小于等于 <span
class="math inline">\(s_{c&#39;}+i* d_{u}\)</span> , 此时 <span
class="math inline">\(d_{u} \leq n_{c&#39;}\)</span> ,
因为我们是从度数大的节点到度数小的节点遍历的, 所以有：<br />
<span class="math display">\[s_{new_c}=s_{c&#39;}+i* d_{u} \leq
n_{c&#39;}^2+i* d_{u} \leq n_{c&#39;}^2+ i* n_{c&#39;} &lt; (n_{c&#39;}+
i)^2= n_{new}\]</span><br />
于是做完了, 怎么感觉这个上界松松的……？ 自己看起来与题解只差了一个 <span
class="math inline">\(\tt{break}\)</span> , 事实上没有证明什么正确性,
差的有点远, 但这样都过了五个点总是会让人产生一点错觉……<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1738/submission/175818123">link</a></p>
<h2 id="codeforces-round-824-div2-22102"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735">Codeforces Round 824 (#Div2)
22/10/2</a></h2>
<p><span class="math inline">\((1537\rightarrow1543,
rk1898)\)</span><br />
……<br />
来看题……</p>
<h3 id="d-14"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735/problem/D">D</a></h3>
<p>为什么考场上摆烂不写, 为什么……<br />
到学校补题, 不看题解 17mins 写+调就过了, 比我一些 B
题用的时间都短……<br />
题意：<br />
  <span class="math inline">\(n\)</span> 张牌(<span
class="math inline">\(n \leq 1000\)</span>), 每张牌有 <span
class="math inline">\(k\)</span> 个维度 (<span class="math inline">\(k
\leq 20\)</span>) , 每个维度有三种取值 0/1/2,
一组三张牌被称为"好的"当且仅当这三张牌的每一个维度的三个取值都相同或不同,
五张牌被称为一个"meta-set"当且仅当里面有两组及以上"好的"牌组, 给你 <span
class="math inline">\(n\)</span> 张牌, 保证互不相同, 问有多少个 meta-set
?<br />
思路：<br />
  分别钦定每个数为 meta-set 中的重复数, 暴力枚举第二个数, <span
class="math inline">\(map\)</span> 查第三个数, 复杂度 <span
class="math inline">\(O(20n^2+n^2\;log\;n), n \leq 1000\)</span> ,
时限四秒只用 139ms, 然后没了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735/submission/175059549">link</a></p>
<h3 id="e-20"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735/problem/E">E</a></h3>
<p>题意：<br />
  在数轴上有 <span class="math inline">\(n(n \leq 1000)\)</span>
个非负整数点 <span class="math inline">\(h_{i}\)</span> , 以及两个位置
<span class="math inline">\(p_{1}, p_{2}\)</span> , 有对应的两个距离数组
<span class="math inline">\(d_{1}, d_{2}\)</span> , 其中 <span
class="math inline">\(d_{i,j}=|h_{j}-p_{i}|\)</span> , <span
class="math inline">\(d_{1}, d_{2}\)</span> 内部的顺序被打乱了, 现在给你
<span class="math inline">\(d_{1}, d_{2}\)</span> , 让你还原一个可能的
<span class="math inline">\(h\)</span> 数组以及 <span
class="math inline">\(p_{1}, p_{2}\)</span> , 或报告不存在满足性质的
<span class="math inline">\(h,p_{1},p_{2}\)</span> 。<br />
思路：<br />
  1h 在机房憋了个假做法, 但可以对正解有部分启示。<br />
  我的想法是, 固定 <span class="math inline">\(p_{1}=0\)</span> , 先把
<span class="math inline">\(d_{1},d_{2}\)</span> 取反后的数组加入(<span
class="math inline">\(n \to 2n\)</span>), 再 sort <span
class="math inline">\(d_{1},d_{2}\)</span> , 把 <span
class="math inline">\(d_{1}\)</span> 扔进 <span
class="math inline">\(map\)</span> 里, 因为 <span
class="math inline">\(\exists \; d_{2,i}\)</span> 满足 <span
class="math inline">\(d_{2,i}=d_{1,N}\)</span> 或 <span
class="math inline">\(d_{2,i}=d_{1,N+1}\)</span> , 我们枚举这个 <span
class="math inline">\(i\)</span> , 保存偏移量, 然后看能不能找到大小为
<span class="math inline">\(n\)</span> 的匹配。<br />
  这个贪心的问题是, 由于 <span class="math inline">\(d_{1},
d_{2}\)</span> 各取反复制了一份, 失去了单调性。正解仅复制 <span
class="math inline">\(d_{1}\)</span> 的正负存进 <span
class="math inline">\(map\)</span> 中, 然后枚举 <span
class="math inline">\(p_{2}=\pm d_{1,i} \pm d_{2,1}\)</span> 中的 <span
class="math inline">\(i\)</span> 和 <span
class="math inline">\(p_{2}\)</span> 的四种情况来保证 <span
class="math inline">\(d_{2,1}\)</span> 的匹配, 然后贪心,
因为对称性我们只考虑 <span class="math inline">\(p_{2} \leq 0\)</span>
的情况(一个负的和一个正的匹配, 对应一定有一个正的与负的匹配)：对于 <span
class="math inline">\(d_{2}\)</span> 中的一个元素 <span
class="math inline">\(x\)</span> , 可能存在的匹配为 <span
class="math inline">\(|p_{2}-x|\)</span> 与 <span
class="math inline">\(|p_{2}+x|\)</span> , <span
class="math inline">\(|p_{2}-x| \geq |p_{2}+x|\)</span> , 所以我们可以将
<span class="math inline">\(d_{2}\)</span>
从大到小排序并优先选择较大数匹配, 因为若当前不与较大数匹配,
则后续无法匹配。<br />
代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735/submission/175308334">link</a><br />
有点抽象, 调了一上午, 寄！</p>
<p>另一个思路：<br />
  考虑对于一个点, 要么到 <span class="math inline">\(p_{1},
p_{2}\)</span> 的距离之和为 <span class="math inline">\(f\)</span> ,
要么到 <span class="math inline">\(p_{1}, p_{2}\)</span>
距离的绝对值之差为 <span class="math inline">\(f\)</span> ,
我们的目标转为找到这个 <span class="math inline">\(f\)</span> , 因为
<span class="math inline">\(\exists \; d_{2,i}\)</span> 满足 <span
class="math inline">\(d_{2,i}=d_{1,1}\)</span> , 这两个点在同一个位置上,
我们可以枚举 <span class="math inline">\(f\)</span> 的 <span
class="math inline">\(2* n\)</span> 种可能性(<span
class="math inline">\(d_{1,1}+d_{2,i}\)</span> 或 <span
class="math inline">\(|d_{1,1}-d_{2,i}|\)</span>) , 判断在钦定边长 <span
class="math inline">\(=f\)</span> 的情况下存不存在大小为 <span
class="math inline">\(n\)</span> 的匹配, dinic 之, 复杂度为 <span
class="math inline">\(O(n^{2.5})\)</span> 。<br />
另一个代码： <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/paste/2dj8da5z">待补,
dinic 之后不会维护捏</a></p>
<h3 id="f-14"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1735/problem/E">F</a></h3>
<h2 id="dytechlab-cup-2022-22107"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1737">Dytechlab Cup 2022
22/10/7</a></h2>
<p><span class="math inline">\((1543\rightarrow1549,
rk2114)\)</span><br />
B 题 WA on pretest 4 查了半天查不出来, 我是**<br />
什么手速场, 赞助场是 div1+2 形式的, 一堆橙、红名还在 D 卡着呢……</p>
<h3 id="d-15"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1737/problem/D">D</a></h3>
<p>题意：<br />
无向图, <span class="math inline">\(n(n \leq 500)\)</span> 个点, <span
class="math inline">\(m(m \leq 250000)\)</span> 条边, 有边权, 要从 <span
class="math inline">\(1\)</span> 点出发到 <span
class="math inline">\(n\)</span> 点,
你可以<strong>在出发前</strong>进行任意次如下操作：<br />
选择 <span class="math inline">\(i\)</span> 号边, 设其连接 <span
class="math inline">\(u_{i}, v_{i}\)</span> , 边权为 <span
class="math inline">\(w_{i}\)</span> , 选择 <span
class="math inline">\(v_{i}\)</span> 通过任意边连接的另一个顶点 <span
class="math inline">\(t_{i}\)</span> (<span
class="math inline">\(t_{i}\)</span> 可等于 <span
class="math inline">\(u_{i}\)</span>) , 断开 <span
class="math inline">\(u_{i}, v_{i}\)</span> 的连接, 连接 <span
class="math inline">\(u_{i}, t_{i}\)</span> , 此举将耗费 <span
class="math inline">\(w_{i}\)</span> 的时间, 边权不变。<br />
问从 <span class="math inline">\(1\)</span> 点出发到 <span
class="math inline">\(n\)</span> 点的最短时间。<br />
思路：<br />
<span class="math inline">\(n \leq 500, floyd\)</span>。<br />
  为什么题干不简单的把边权翻倍? 因为一条边可能在图上"转来转去",
移到任何地方, 例如, 在 codeforces 上的这个样例中：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/g34seaiq.png" /><br />
答案是 <span class="math inline">\(154\)</span> , 2 &lt;-&gt; 5
之间边权为 22 的边移动了六次, 连接了起点和终点, 最后加上一次走边的代价,
22 * 7 = 154。<br />
因为重边有用, 可以转出去, 存图时只要存图的连通性就好。<br />
  一个 <span class="math inline">\(key\; observation\)</span> 是,
最短路一定可以直接连接 <span class="math inline">\(1\)</span> 与 <span
class="math inline">\(n\)</span> 号点, 假设最短路不直接连接首尾, 例如 1
&lt;-&gt; u &lt;-&gt; v &lt;-&gt; N ,
我们可以直接选择最短路上的最短边让它两头扩展连接首尾,
现在我们只要处理每一条边是不是最短边就好。<br />
1、若一条边本身就在起点到终点的路径里, 我们可以直接扩展它至首尾。<br />
2、若一条边本身不在起点到终点的路径里, 我们让它探到路径上的一个点,
称为中转点, 再在这个点上收缩形成自环, 再伸展至首尾。<br />
代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=inf;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=M;i++)&#123; </span><br><span class="line">	<span class="type">int</span> u=op[i].u, v=op[i].v, w=op[i].w;</span><br><span class="line">	ans=<span class="built_in">min</span>(ans,w*<span class="built_in">min</span>(d[<span class="number">1</span>][u]+d[v][N]+<span class="number">1</span>,d[<span class="number">1</span>][v]+d[u][N]+<span class="number">1</span>)); <span class="comment">//on the final path</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=N;j++)&#123; <span class="comment">//enumerate the transfer point			</span></span><br><span class="line">		ans=<span class="built_in">min</span>(ans,w*(d[<span class="number">1</span>][j]+d[j][N]+d[v][j]+<span class="number">2</span>)); <span class="comment">// attach, shrink, and extend</span></span><br><span class="line">		ans=<span class="built_in">min</span>(ans,w*(d[<span class="number">1</span>][j]+d[j][N]+d[u][j]+<span class="number">2</span>));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>若有边 i &lt;-&gt; j, d[i][j]=d[j][i]=1, 然后跑 <span
class="math inline">\(floyd\)</span> 。<br />
上面的 +1 是走边的代价, 下面的 +2 是走边的代价加上缩成自环的代价,
好题！</p>
<h3 id="e-21"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1737/problem/E">E</a></h3>
<h2 id="codeforces-round-825-div2-221010"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1736">Codeforces Round 825 (#Div2)
22/10/10</a></h2>
<p><span class="math inline">\((1549\rightarrow1711,
rk224)\)</span><br />
<span class="math inline">\(+162\)</span> ! 只要你分数够低,
总有可能上大分！<br />
D 的构造想出来了, C2 线段树不会, 在手速场(C1:5500通过
C2:102通过)小寄大赢！<br />
B Wa 了两发, 下次想好再写题, 不然做不出 D 又掉到 1000 名左右去了……</p>
<h3 id="c2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1736/problem/C2">C2</a></h3>
<p>题意：<br />
给你 <span class="math inline">\(a\)</span> 数组, 长度为 <span
class="math inline">\(n\)</span> ,定义好数组 <span
class="math inline">\([a_{l},a_{l+1},a_{l+2},...,a_{r}]\)</span> 满足
<span class="math inline">\(\forall \; i, a_{i} \geq i-l+1, (a_{l} \geq
1, a_{l+1} \geq 2, ..., a_{r} \geq r-l+1)\)</span>。 <span
class="math inline">\(Q\)</span> 次单点修改(<span
class="math inline">\(a_{p}=v\)</span>)且相互独立,
要求输出在每次修改后整个 <span class="math inline">\(a\)</span>
数组好的子数组的数目。<br />
<span class="math inline">\(a_{i},n,Q \leq 2e5\)</span><br />
思路：<br />
  C1 没有修改, 仅询问一次, 我就固定遍历左端点, 二分能达到的右端点,
提前递推一个辅助数组判断 <span class="math inline">\(i\)</span>
端点开头的线段在哪儿结束即可, 网上更简单的做法是 DP 或直接双指针弄一下。
带修之后双指针不行了, 但还可以用来处理初始答案,
我们注意到每次更新会改变一段连续端点开头的线段,
因为它们的右端点一定是递增的。<br />
  设 <span class="math inline">\(i\)</span> 端点开头的线段结束点为 <span
class="math inline">\(j\)</span> , 这里定义为线段右端点后面的一个点,
单点更新可能会造成结束点的点值增加, 增长线段长度,
我们还要处理若结束点增长到足够大时以 <span
class="math inline">\(i\)</span>
节点为开头的新的线段长度(或新的线段长度与原线段长度的差分),
至于结束点是否真的能增长到足够大我们在统计时再判断好了,
从前往后的起始节点若拥有同一个结束点,
那么它们对结束点的要求一定是越来越低的, 若已知 <span
class="math inline">\(p,v\)</span> , 这部分的约束为 <span
class="math inline">\(max(1,p-v+1)\)</span> , 再与其他的约束取个 <span
class="math inline">\(max\)</span> 即可,
这里求的是增加点值可能影响的线段区间的左端点最小值。<br />
  谈远了……要维护新的线段长度我们可以直接上线段树二分, 之前优先处理 <span
class="math inline">\(a_{i}-i\)</span> 较大的位置, 线段树二分出结束点
<span class="math inline">\(j\)</span> , 更新 <span
class="math inline">\(j\)</span> 点, 求出新的终点(新长度与原长度的差分),
再把 <span class="math inline">\(j\)</span> 点更新回来。对结束点,
长度查分大小都做要一个前缀和。长度查分大小的前缀和可以帮我们统计在 <span
class="math inline">\(v&gt;a_{p}\)</span> 时 <span
class="math inline">\(p\)</span> 点的增长对左边造成的影响。<br />
  至于 <span class="math inline">\(v&lt;a_{p}\)</span> 的情况,
它会对左边以 <span class="math inline">\(\geq p+1\)</span>
为结束点的线段产生影响, 最多能影响到 <span
class="math inline">\(max(0,p-v)\)</span> 位置,
同样求出区间后我们拿结束点前缀和搞一搞就能统计了。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;<span class="keyword">return</span> ar[a]-a&gt;ar[b]-b;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">upd</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> pos, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s==e&amp;&amp;s==pos) &#123;t[n]=val; <span class="keyword">return</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="type">int</span> mid=(s+e)&gt;&gt;<span class="number">1</span>, ln=<span class="number">2</span>*n, rn=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(pos&lt;=mid) <span class="built_in">upd</span>(ln,s,mid,pos,val);</span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">upd</span>(rn,mid+<span class="number">1</span>,e,pos,val);</span><br><span class="line">		t[n]=<span class="built_in">min</span>(t[ln],t[rn]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(s&gt;R||e&lt;L) <span class="keyword">return</span> N+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s&gt;=L&amp;&amp;e&lt;=R) &#123;</span><br><span class="line">		<span class="keyword">if</span>(t[n]&gt;val) <span class="keyword">return</span> N+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">if</span>(s==e) <span class="keyword">return</span> s;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> mid=(s+e)&gt;&gt;<span class="number">1</span>, ln=<span class="number">2</span>*n, rn=<span class="number">2</span>*n+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span>(t[ln]&lt;=val) <span class="keyword">return</span> <span class="built_in">find</span>(ln,s,mid,L,R,val);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">find</span>(rn,mid+<span class="number">1</span>,e,L,R,val);	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	N=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) ar[i]=<span class="built_in">read</span>(), id[i]=i;</span><br><span class="line">	<span class="built_in">sort</span>(id+<span class="number">1</span>,id+<span class="number">1</span>+N,cmp); <span class="comment">//high delta (ar[i]-i) first</span></span><br><span class="line">	<span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>,r=<span class="number">1</span>;i&lt;=N;i++)&#123; <span class="comment">//pointer i, pointer r, j is for the addition of ar[id[j]]</span></span><br><span class="line">		<span class="keyword">while</span>(j+<span class="number">1</span>&lt;=N &amp;&amp; ar[id[j+<span class="number">1</span>]]-id[j+<span class="number">1</span>]+i<span class="number">-1</span>&gt;=<span class="number">0</span>) &#123;<span class="comment">// Solved by delta order, so we can put two pointers on it instead of restart every time		</span></span><br><span class="line">			j++; <span class="comment">//id[j] represent the things now we can reach.</span></span><br><span class="line">			<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,N,id[j],<span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		r=<span class="built_in">find</span>(<span class="number">1</span>,<span class="number">1</span>,N,i,N,<span class="number">0</span>); <span class="comment">// r represent the things nearest we can not reach. ~\Sacred Binary Search/~</span></span><br><span class="line">		R[i]=r; ans+=r-i;</span><br><span class="line">		<span class="keyword">if</span>(r&lt;=N) &#123;</span><br><span class="line">			<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,N,r,<span class="number">1</span>); <span class="comment">//remove the obstacle r</span></span><br><span class="line">			nxt[i]=<span class="built_in">find</span>(<span class="number">1</span>,<span class="number">1</span>,N,i,N,<span class="number">0</span>)-R[i]; <span class="comment">// if we remove the obstacle r, the extra distance we can extend is nxt[i].</span></span><br><span class="line">			<span class="built_in">upd</span>(<span class="number">1</span>,<span class="number">1</span>,N,r,<span class="number">0</span>); <span class="comment">//regain the obstacle r</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) prenxt[i]=prenxt[i<span class="number">-1</span>]+nxt[i]; <span class="comment">//prefix of nxt[]</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++) preR[i]=preR[i<span class="number">-1</span>]+R[i]; <span class="comment">//prefix of R[]</span></span><br><span class="line">	Q=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(Q--)&#123;</span><br><span class="line">		<span class="type">int</span> pos=<span class="built_in">read</span>(), val=<span class="built_in">read</span>();</span><br><span class="line">		<span class="keyword">if</span>(ar[pos]==val) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ar[pos]&lt;val)&#123; <span class="comment">//we will get higher score												   </span></span><br><span class="line"> 			<span class="type">int</span> RB=<span class="built_in">upper_bound</span>(R+<span class="number">1</span>,R+pos,pos)-R<span class="number">-1</span>; <span class="comment">// R+1 first - 1 = R last</span></span><br><span class="line">			<span class="type">int</span> LB=<span class="built_in">lower_bound</span>(R+<span class="number">1</span>,R+pos,pos)-R;   <span class="comment">//R first</span></span><br><span class="line">			LB=<span class="built_in">max</span>(LB,<span class="built_in">max</span>(<span class="built_in">ll</span>(<span class="number">1</span>),pos-val+<span class="number">1</span>)); <span class="comment">// only increasing enough value can let others getover the obstacle.</span></span><br><span class="line">			<span class="keyword">if</span>(LB&gt;RB) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; ans+prenxt[RB]-prenxt[LB<span class="number">-1</span>] &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(ar[pos]&gt;val)&#123; <span class="comment">//we will get smaller score		</span></span><br><span class="line">			<span class="type">int</span> LB=<span class="built_in">upper_bound</span>(R+<span class="number">1</span>,R+pos,pos)-R; <span class="comment">//R+1 first = first affected</span></span><br><span class="line">			<span class="type">int</span> RB=<span class="built_in">max</span>(<span class="built_in">ll</span>(<span class="number">0</span>),pos-val); <span class="comment">// last affected</span></span><br><span class="line">			<span class="keyword">if</span>(LB&gt;RB) cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">			<span class="keyword">else</span> cout &lt;&lt; ans-(preR[RB]-preR[LB<span class="number">-1</span>])+(RB-LB+<span class="number">1</span>)*pos &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// mind the non-answer part adding and erasing</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 锐评：肯定是我做过最难的 C 了</p>
<h3 id="e-22"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1736/problem/E">E</a></h3>
<p>Editorial 都拖着不出, 不想补……</p>
<h2 id="codeforces-global-round-23-221015"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1746">Codeforces Global Round 23
22/10/15</a></h2>
<p><span class="math inline">\((1711\rightarrow1712,
rk1691)\)</span><br />
被 D 诈骗力, 应该三十分钟离场去打游戏的, 看起来这场都是妙妙题, 我不会做,
但我大受震撼。</p>
<h3 id="d-16"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1746/problem/D">D</a></h3>
<p>题意：<br />
给定一颗 <span class="math inline">\(1\)</span> 为根节点的 <span
class="math inline">\(n(n \leq 2e5)\)</span> 个节点树,
每个节点有一个权值 <span class="math inline">\(s_{i}(s_{i} \leq
1e4)\)</span> , 一个 <span class="math inline">\(k(k \leq 1e9)\)</span>
条简单路径的<strong>多重集</strong>称为合法,
当且仅当满足下面的条件：<br />
- 每条路径从根节点开始 - 设 <span class="math inline">\(c_{i}\)</span>
为经过 <span class="math inline">\(i\)</span> 节点的路径数, 若 <span
class="math inline">\(u, v\)</span> 拥有共同的祖先, 则 <span
class="math inline">\(|c_{u}-c_{v}| \leq 1\)</span></p>
<p>给定 <span class="math inline">\(k\)</span> , 问 <span
class="math inline">\(\sum c_{i}* s_{i}\)</span> 的最大值。<br />
思路：<br />
  显然能注意到的一点是, 为了让答案更大, 所有的路径都要延伸到叶节点, 即 $
<em>{v son</em>{u}}{c_{v}}= c_{u}$ 。<br />
  设节点 <span class="math inline">\(u\)</span> 有 <span
class="math inline">\(x\)</span> 个儿子, 所以 <span
class="math inline">\(\forall v \in son_{u}, \; c_{v}= \lceil c_{u}/x
\rceil \;or\; \lfloor c_{u}/x \rfloor\)</span> ,
我们可以将这两种状态设为 <span class="math inline">\(f_{v,1}\)</span> 和
<span class="math inline">\(f_{v,0}\)</span> , 我们求出 <span
class="math inline">\(u\)</span> 的每个儿子的两种状态, 让 <span
class="math inline">\(c_{u} \; mod \; x\)</span> 个取 <span
class="math inline">\(1\)</span> 状态, 剩下的取 <span
class="math inline">\(0\)</span> 状态, 这个可以通过排序解决, 具体来说,
我们按 <span class="math inline">\(f_{v,1}-f_{v,0}\)</span> 排序,
增量越大越优先。总的思想是树形DP, 这个很好想, 但我不会实现……<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1746/submission/176649053">link</a>
我们默认 <span class="math inline">\(\lceil c_{u}/x \rceil = \lfloor
c_{u}/x \rfloor + 1\)</span> , 至于是不是其实无所谓……</p>
<h3 id="e1-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1746/problem/E1">E1</a></h3>
<p>又到了奇妙的交互+构造题<br />
题意：<br />
给定一个 <span class="math inline">\(n(n \leq 1e5)\)</span> ,
让你猜一个数 <span class="math inline">\(x \in [1,n]\)</span> , 至多
<span class="math inline">\(82\)</span> 次猜测,
每次你可以<strong>询问</strong> <span
class="math inline">\([1,n]\)</span> 中的一个子集, 回复你 <span
class="math inline">\(x\)</span> 在不在这个子集中, 但是系统可能说谎,
不过可以保证<strong>连续的两次询问</strong>中一定有一次系统没有说谎,
<span class="math inline">\(x\)</span>
的值可能随着询问而<strong>动态改变</strong>, 不过一定满足之前的约束。
你一共有两次<strong>猜测</strong> <span class="math inline">\(x\)</span>
的机会。<br />
思路：<br />
这个 <span class="math inline">\(82\)</span> 实在是看不出什么名堂,
思考一下我们怎么保证得到正确且有用的信息, 来缩小范围。<br />
我们可以将数字集合分为不相交的 <span class="math inline">\(A, B, C,
D\)</span> 四部分, 询问 <span class="math inline">\(A \cup B\)</span>
以及 <span class="math inline">\(C\)</span> , 设 <span
class="math inline">\(True\)</span> 为回复在这个子集里, <span
class="math inline">\(False\)</span> 为回复不在这个子集里,
我们可以分类讨论：<br />
1. <span class="math inline">\(A \cup B=True, \; C=False\)</span><br />
1.1 前者说谎且后者未说谎, 实际为 <span class="math inline">\(A \cup
B=False, \; C=False\)</span> , 可排除 <span class="math inline">\(A, B,
C\)</span> 。<br />
1.2 前者未说谎且后者未说谎, 实际为 <span class="math inline">\(A \cup
B=True, \; C=False\)</span> , 可排除 <span class="math inline">\(C,
D\)</span> 。 2. <span class="math inline">\(A \cup B=True, \;
C=True\)</span><br />
2.1 前者说谎且后者未说谎, 实际为 <span class="math inline">\(A \cup
B=False, \; C=True\)</span> , 可排除 <span class="math inline">\(A, B,
D\)</span> 。<br />
2.2 前者未说谎且后者说谎, 实际为 <span class="math inline">\(A \cup
B=True, \; C=False\)</span> , 可排除 <span class="math inline">\(C,
D\)</span> 。 3. <span class="math inline">\(A \cup B=False\)</span>
等价于 <span class="math inline">\(C \cup D=True\)</span> 进行 <span
class="math inline">\(swap(A \cup B), swap(C \cup D)\)</span> 即可。</p>
<p>上述的分类讨论都省去了矛盾的部分, 我们固定了 <span
class="math inline">\(A \cup B\)</span> , 加入了更多的约束,
现在我们可以根据 <span class="math inline">\(C\)</span> 的 <span
class="math inline">\(True/False\)</span> 来排除部分数集, 取一下交集,
我们可以在 <span class="math inline">\(C=False\)</span> 时排除 <span
class="math inline">\(C\)</span> 部分, 在 <span
class="math inline">\(C=True\)</span> 时排除 <span
class="math inline">\(D\)</span> 部分。
这样每两次操作我们可以把数据规模大小从 <span
class="math inline">\(n\)</span> 变为 <span class="math inline">\(\lceil
\frac{3}{4}* n \rceil\)</span> 。<br />
如果还剩余三个及以下的数怎么办？ 因为最后可以问两次,
我们只要考虑剩三个数时的策略即可。<br />
设这三个数为 <span class="math inline">\(A, B, C\)</span> , 询问 <span
class="math inline">\(A, B\)</span> 各一次, 则：<br />
1. <span class="math inline">\(A=True, \; B=True\)</span> 因为 <span
class="math inline">\(A, B\)</span> 不可能全为假, 则 <span
class="math inline">\(C\)</span> 一定为假, 可以排除 <span
class="math inline">\(C\)</span> 。 2. <span
class="math inline">\(A=True, \; B=False\)</span> 分类取交集可排除 <span
class="math inline">\(B\)</span> , 具体见下。<br />
2.1 前者说谎且后者未说谎, 实际为 <span class="math inline">\(A=False,
B=False\)</span> , 可排除 <span class="math inline">\(A,
B\)</span><br />
2.2 前者未说谎且后者说谎, 实际为 <span class="math inline">\(A=True,
B=True\)</span> , 矛盾<br />
2.3 前者未说谎且后者未说谎, 实际为 <span class="math inline">\(A=True,
B=False\)</span> , 可排除 <span class="math inline">\(B, C\)</span> 3.
<span class="math inline">\(A=False, \; B=True\)</span> 分类取交集可排除
<span class="math inline">\(A\)</span> , 与 2. 同理。<br />
4. <span class="math inline">\(A=False, \; B=False\)</span> ,
我们可以再问一次 <span class="math inline">\(B\)</span> , 然后再问一次
<span class="math inline">\(A\)</span> 决定排除谁, 具体见下。<br />
4.1 重问中存在 <span class="math inline">\(True\)</span> 的回答,
一定可以转化为上面三种大状况之一。<br />
4.2 重问也全为 <span class="math inline">\(False\)</span> , 因为两次的
<span class="math inline">\(B\)</span> 是连续询问的且全为 <span
class="math inline">\(False\)</span> , 所以我们可以排除 <span
class="math inline">\(B\)</span></p>
<p>艹！好难想！<br />
代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1746/submission/176666787">link</a></p>
<h2 id="educational-codeforces-round-137-div2-221017"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1743">Educational Codeforces Round
137 (#Div2) 22/10/17</a></h2>
<p><span class="math inline">\((1712\rightarrow1791,
rk377)\)</span><br />
好! DP 不会! 但糊了D! 希望下次继续!</p>
<h3 id="e-23"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1743/problem/E">E</a></h3>
<p>题意：<br />
  有一个敌人, 血量为 <span class="math inline">\(h\)</span> ,
你有两把武器, 伤害和攻击冷却时间分别为 <span
class="math inline">\(p_{1}, t_{1}, p_{2}, t_{2}\)</span>
。当武器冷却完成时, 你可以使用一把,
或是等到两把武器都冷却完成时一起使用, 会造成 <span
class="math inline">\(P-s\)</span> 的伤害, 其中 <span
class="math inline">\(s\)</span> 是一个给定的值(护盾?), <span
class="math inline">\(P\)</span> 是使用的武器的伤害的总和。<br />
问可以消灭敌人(使其血量 <span class="math inline">\(\leq
0\)</span>)的最少时间(初始两把武器都需要完全冷却)。<br />
<span class="math inline">\(1 \leq  h,p_{1},p_{2} \leq 5000, 1 \leq s
&lt; min(p_{1},p_{2}), t_{1}, t_{2} \leq 1e12\)</span><br />
思路：<br />
<span class="math inline">\(\tt{dp}\)</span> 是显然的,
状态是不会列的。<br />
考虑到每次同时使用两把武器时, 冷却时间都重置为 <span
class="math inline">\(0\)</span> , 转化为一个更低 <span
class="math inline">\(h\)</span> 的子问题。<br />
我们直接设 <span class="math inline">\(f[i]\)</span> 表示造成 <span
class="math inline">\(i\)</span> 点伤害所需的最短时间, <span
class="math inline">\(f[i]\)</span>
可以通过单发射击以及更复杂的齐射转移而来。<br />
<span
class="math display">\[f[i]=min(f[max(0,i-(p_{1}-s))]+t_{1},f[max(0,i-(p_{2}-s))]+t_{2})\]</span><br />
这代表造成 <span class="math inline">\(i\)</span>
点伤害的最短时间可以由造成 <span class="math inline">\(i-p_{1}\)</span>
或 <span class="math inline">\(i-p_{2}\)</span> 伤害的最短时间加上 <span
class="math inline">\(t_{1}\)</span> 或 <span
class="math inline">\(t_{2}\)</span> 的冷却时间转移。<br />
接下来考虑复杂转移：考虑进行 <span class="math inline">\(j\)</span>
次射击某一把武器, 其中最后一次是齐射, 下文以 <span
class="math inline">\(j\)</span> 次使用第一把武器射击为例：<br />
第一把的独立贡献为： <span class="math inline">\((j-1)*
(p_{1}-s)\)</span><br />
第二把的独立贡献为： <span class="math inline">\((j* t_{1}-t_{2})/t_{2}*
(p_{2}-s)\)</span><br />
齐射的贡献为： <span class="math inline">\(p_{1}+p_{2}-s\)</span><br />
总贡献为：<br />
<span class="math display">\[D=(j-1)* (p_{1}-s)+(j* t_{1}-t_{2})/t_{2}*
(p_{2}-s)+p_{1}+p_{2}-s\]</span><br />
转移方程为： <span class="math inline">\(f[i]=min(f[i],f[max(0,i-D)]+j*
t_{1}\)</span><br />
使用另一把武器同理, 总复杂度为 <span
class="math inline">\(O(n^2)\)</span><br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1743/submission/177292305">link</a></p>
<h3 id="f-15"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1743/problem/F">F</a></h3>
<p>矩阵 + 线段树, 不会矩阵……</p>
<h3 id="g-1"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1743/problem/G">G</a></h3>
<p>DP</p>
<h2 id="educational-codeforces-round-138-div2-221020"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1749">Educational Codeforces Round
138 (#Div2) 22/10/20</a></h2>
<p><span class="math inline">\((1791\rightarrow1780,
rk1050)\)</span><br />
后排膜 <span
class="math inline">\(\color{black}{\tt{L}}\color{red}{\tt{STM\_\_}}\)</span><br />
三十场题解了, 还是只会ABC, 怎么办呢？<br />
在家的效率很差, 很有发癫的冲动, 或是进行强迫性摆烂行为。<br />
唯一的梦想是 codeforces 上 1900, 可能还有一个出codeforces div2的梦想,
但那个不着急。写不出来什么了, 我高中以来没有什么表达的冲动,
憋这几行字就是极限了, 有点伤心。</p>
<h3 id="d-17"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1749/problem/D">D</a></h3>
<p>题意：<br />
对于一个数组 <span class="math inline">\(a\)</span> , 如果 <span
class="math inline">\(gcd(a_{i},i)=1\)</span> 就可以删除第 <span
class="math inline">\(i\)</span>
个元素并把后面的元素前移并重新标号。<br />
现在给定 <span class="math inline">\(n, m(n \leq 3e5, m \leq
1e12)\)</span> ,
要求求满足以下条件的有多种删空数组的方式的数组的数目：<br />
- <span class="math inline">\(a\)</span> 的长度小于 <span
class="math inline">\(n\)</span> - <span class="math inline">\(a_{i}
\leq m\)</span></p>
<p>思路：<br />
正难则反, 考虑仅有一种删空方式的数组的删除序列, 一定是 <span
class="math inline">\(1,1,1,...\)</span> 形式的。这要求第一个数随便取,
第 <span class="math inline">\(i\)</span> 个数必须与 <span
class="math inline">\([2,i]\)</span> 内的每个数<strong>不互质</strong>,
所以我们把 <span class="math inline">\([2,i]\)</span>
内的每个质数乘起来就好了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1749/submission/177311545">link</a></p>
<h3 id="e-24"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1749/problem/E">E</a></h3>
<p>题意：<br />
  给定 <span class="math inline">\(n * m(n* m \leq 4e5)\)</span> 的棋盘,
初始存在一些仙人掌, 你要再种最少数量的仙人掌使得没有第一行到第 <span
class="math inline">\(n\)</span> 行的路径,
种仙人掌的格子之间不能有公共边。<br />
思路：<br />
  仙人掌分割第一行与第 <span class="math inline">\(n\)</span>
行等价于存在一条第一列到第 <span class="math inline">\(m\)</span>
列的仙人掌路径, 于是去写一个 bfs, 于是过了。<br />
代码：<br />
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> N, M, T;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;; <span class="comment">//注意 dx[0]/dy[0] 的不同</span></span><br><span class="line"><span class="type">int</span> dy[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dx2[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy2[<span class="number">5</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;<span class="type">int</span> x, y;&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//	freopen(&quot;testdata.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line">	T=<span class="built_in">read</span>();</span><br><span class="line">	<span class="keyword">while</span>(T--)&#123;</span><br><span class="line">		N=<span class="built_in">read</span>(); M=<span class="built_in">read</span>();</span><br><span class="line">		vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">mp</span>(N+<span class="number">2</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M+<span class="number">1</span>)), <span class="built_in">dis</span>(N+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M+<span class="number">1</span>, inf)), <span class="built_in">pre</span>(N+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(M+<span class="number">1</span>));		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			string s;</span><br><span class="line">			cin &gt;&gt; s; s=<span class="string">&quot; &quot;</span>+s;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">				mp[i][j]=(s[j]==<span class="string">&#x27;#&#x27;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">		deque&lt;node&gt; q;	<span class="comment">//depue push_front, pusk_back 控制访问顺序, 因为我不会 lambda</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(mp[i][<span class="number">1</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">				dis[i][<span class="number">1</span>]=<span class="number">0</span>; pre[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">				q.<span class="built_in">push_front</span>((node)&#123;i,<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(mp[i][<span class="number">1</span>]==<span class="number">0</span>&amp;&amp;mp[i<span class="number">-1</span>][<span class="number">1</span>]+mp[i+<span class="number">1</span>][<span class="number">1</span>]&lt;<span class="number">1</span>)&#123; <span class="comment">//不是所有第一列的点都能作为初始点</span></span><br><span class="line">				dis[i][<span class="number">1</span>]=<span class="number">1</span>; pre[i][<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">				q.<span class="built_in">push_back</span>((node)&#123;i,<span class="number">1</span>&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			node tmp=q.<span class="built_in">front</span>(); q.<span class="built_in">pop_front</span>();</span><br><span class="line">			<span class="type">int</span> x=tmp.x, y=tmp.y;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)&#123;</span><br><span class="line">				<span class="type">int</span> nx=x+dx[i], ny=y+dy[i];</span><br><span class="line">				<span class="type">int</span> tag=<span class="number">0</span>;</span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">4</span>;j++) &#123; <span class="comment">//判断 bfs 到的点能否种植仙人掌, 不写成函数因为我不会 lambda</span></span><br><span class="line">					<span class="type">int</span> nnx=nx+dx2[j], nny=ny+dy2[j];</span><br><span class="line">					<span class="keyword">if</span>(nny&gt;M||nny&lt;<span class="number">1</span>||nnx&gt;N||nnx&lt;<span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">					<span class="keyword">if</span>(mp[nnx][nny]) tag=<span class="number">1</span>;</span><br><span class="line">				&#125;				</span><br><span class="line">				<span class="keyword">if</span>(nx&lt;<span class="number">1</span>||ny&lt;<span class="number">1</span>||nx&gt;N||ny&gt;M||dis[nx][ny]!=inf||tag) <span class="keyword">continue</span>;</span><br><span class="line">				pre[nx][ny]=i; <span class="comment">//保存转移路径, 最后回溯</span></span><br><span class="line">				dis[nx][ny]=dis[x][y];</span><br><span class="line">				<span class="keyword">if</span>(mp[nx][ny]==<span class="number">1</span>) q.<span class="built_in">push_front</span>((node)&#123;nx,ny&#125;);</span><br><span class="line">				<span class="keyword">else</span> dis[nx][ny]++, q.<span class="built_in">push_back</span>((node)&#123;nx,ny&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;			</span><br><span class="line">		<span class="type">int</span> ans=inf, pos=<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(dis[i][M]&gt;=ans) <span class="keyword">continue</span>;</span><br><span class="line">			ans=dis[i][M], pos=i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(pos==<span class="number">-1</span>) &#123;cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>; <span class="keyword">continue</span>;&#125;</span><br><span class="line">		<span class="type">int</span> tmpM=M;   </span><br><span class="line">		<span class="keyword">while</span>(tmpM) &#123; <span class="comment">//回溯, 第一列用 dx[0]/dy[0], 有点丑</span></span><br><span class="line">			<span class="type">int</span> x=dx[pre[pos][tmpM]], y=dy[pre[pos][tmpM]];</span><br><span class="line">			mp[pos][tmpM]=<span class="number">1</span>;</span><br><span class="line">			pos-=x; tmpM-=y;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=M;j++)</span><br><span class="line">				mp[i][j]?cout &lt;&lt; <span class="string">&quot;#&quot;</span>:cout &lt;&lt; <span class="string">&quot;.&quot;</span>; cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;	</span><br><span class="line">		&#125;			</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> (<span class="number">0</span><span class="number">-0</span>);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 有谁能教我 lambda 表达式,
这样我们就都不用忍受又臭又长的代码了……</p>
<h3 id="f-16"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1749/problem/F">F</a></h3>
<p>于 22.11.21 晚尝试补题, 拖了一个月, 看看之前发癫的人。<br />
题意：<br />
给定一颗树, 点有点权, 初始为 <span class="math inline">\(0\)</span> ,
有以下两种操作：<br />
1.询问某点点权<br />
2.将树上所有到 从 <span class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的路径的距离不超过 <span
class="math inline">\(d\)</span> 的点的点权加上 <span
class="math inline">\(k\)</span><br />
<span class="math inline">\(n, q \leq 2e5, d \leq 20, k \leq
1000\)</span><br />
思路：<br />
<span class="math inline">\(d=0\)</span> 就是经典的树链剖分问题了, <span
class="math inline">\(d \neq 0\)</span> 怎么办, 看到 <span
class="math inline">\(d\)</span> 的范围很小, 考虑暴力维护, 。<br />
具体怎么维护呢？我们可以先简化问题, 每次只更新一个点 <span
class="math inline">\(u\)</span> 。我们可以设 <span
class="math inline">\(bit[u][d]\)</span> 记录对于每个点 <span
class="math inline">\(u\)</span> , 在 <span
class="math inline">\(u\)</span> 的<strong>子树</strong>中距离 <span
class="math inline">\(u\)</span> 的距离为 <span
class="math inline">\(d\)</span>
的节点增加的权值。这么定义是因为这些节点只有 <span
class="math inline">\(u\)</span> 才能 "够到" 。每次我们更新一个 <span
class="math inline">\(u\)</span> 点, 我们要更新 <span
class="math inline">\(bit[u][d]\)</span> , <span
class="math inline">\(bit[fa[u]][d] \;\&amp;\&amp;\;
bit[fa[u]][d-1]\)</span> , <span
class="math inline">\(bit[fa[fa[u]]][d-1] \;\&amp;\&amp;\;
bit[fa[fa[u]]][d-2].....\)</span> 直到 <span
class="math inline">\(d=0\)</span> 为止, 做到不重不漏。
每次更新一条链也是同理的, 我们把链总可以拆成自顶向下的一段或两段,
设这样的一段链 u-v 中, <span class="math inline">\(dep[u] \leq
dep[v]\)</span> , 对于 <span class="math inline">\([u+1,v]\)</span>
这些节点, 我们更新 <span class="math inline">\(bit[i][d]\)</span> ,
而对于 <span class="math inline">\(u\)</span> 及以上的点, 我们更新 <span
class="math inline">\(bit[fa[u]][d] \;\&amp;\&amp;\;
bit[fa[u]][d-1]\)</span> , <span
class="math inline">\(bit[fa[fa[u]]][d-1] \;\&amp;\&amp;\;
bit[fa[fa[u]]][d-2].....\)</span> 这样同理向上, 跳一格, 更新两格。<br />
在询问一点 <span class="math inline">\(u\)</span> 的权值时, 我们只要把
<span class="math inline">\(bit[u][0], bit[fa[u]][1], ...,
bit[n][d]\)</span> 求和就行了, 复杂度 <span class="math inline">\(O(20 *
n log^2 n)\)</span>。 代码： <a
target="_blank" rel="noopener" href="https://codeforces.com/problemset/submission/1749/182076747">link</a><br />
注意若暴力上跳时, 若 <span class="math inline">\(d\)</span> 还没有
"用完" , 但已经跳到根节点了, 就要在根节点把 <span
class="math inline">\(d\)</span> 用完。</p>
<h2 id="codeforces-round-829-div2-221023"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1754">Codeforces Round 829 (#Div2)
22/10/23</a></h2>
<p><span class="math inline">\((1779\rightarrow1816,
rk400)\)</span><br />
这是 10/23 打的第一场比赛, 难度偏低, 第一次糊出五题(如果C1,
C2算两题的话……)。 E 简单期望不会…… 其中 C2 和 D 都是糊一个结论过的……
上了 <span class="math inline">\(1800\)</span>, 但只上了 2h……</p>
<h3 id="e-25"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/problem/E">E</a></h3>
<p>题意：<br />
  给定一个长度为 <span class="math inline">\(n\)</span> 的 <span
class="math inline">\(01\)</span> 数组 <span
class="math inline">\(a\)</span> , 每次随机选择两个数, 若 <span
class="math inline">\(i&gt;j \;\&amp;\&amp;\; a_{i}&lt;a_{j}\)</span>
则交换, <strong>期望</strong>多少次能让数组变得有序(升序)。<br />
思路：<br />
  不会期望, 直接被吓跑力~<br />
  假设 <span class="math inline">\(a\)</span> 中有 <span
class="math inline">\(cnt_{0}\)</span> 个 <span
class="math inline">\(0\)</span> , 那么它们一定在前 <span
class="math inline">\(cnt_{0}\)</span> 个位置,
我们的<strong>有效操作</strong>就是把前 <span
class="math inline">\(cnt_{0}\)</span> 个数中的 <span
class="math inline">\(1\)</span> 与后面的 <span
class="math inline">\(0\)</span> 交换, 设前 <span
class="math inline">\(cnt_{0}\)</span> 个数中有 <span
class="math inline">\(x\)</span> 个 <span
class="math inline">\(1\)</span> ， 则后面也一定有 <span
class="math inline">\(x\)</span> 个 <span
class="math inline">\(0\)</span> , 所以有效操作的概率为 <span
class="math inline">\(\dfrac{x^2}{C_n^2}\)</span> , 期望为概率的倒数, 即
<span class="math inline">\(\dfrac{C_n^2}{x^2}\)</span> ,
每一步加上就是最后的答案。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/submission/177663822">link</a></p>
<h3 id="f-17"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/problem/F">F</a></h3>
<p>题意：<br />
  在 <span class="math inline">\(n \times m (n \times m \leq
3e5)\)</span> 的沙滩方格上有一些 <span class="math inline">\(1 \times
2\)</span> 的躺椅, <span class="math inline">\(1 \times 1\)</span>
的障碍和一些空格, 你想要找到 <span class="math inline">\(1 \times
2\)</span> 的空地放下自己的躺椅。障碍不可移动, 你可以花费 <span
class="math inline">\(p\)</span> 使得一个躺椅旋转 <span
class="math inline">\(90\)</span> 度放置, 也可以花费 <span
class="math inline">\(q\)</span> 使得一个躺椅沿着长边方向平移一格,
移动躺椅需要保证移动后的位置是没有障碍的。问找到 <span
class="math inline">\(1 \times 2\)</span> 空地的最小移动花费,
或报告无法找到空地。<br />
思路：<br />
  从 <span class="math inline">\(1 \times 2\)</span>
的躺椅联想到黑白染色, 若将躺椅的移动看成空格的移动,
不难发现每次都是黑格移到黑格, 白格移到白格,
最后我们放置躺椅的位置也是一黑一白的。<br />
  我们可以证明, 在最佳情况下, 每个躺椅的移动不超过一次,
我有一个感性的理解, 每次移动要么从黑格移到黑格, 要么从白格移到白格,
若移动两次说明既进行了一次黑格的移动也进行了一次白格的移动,
然而考虑躺椅及其周围一共八个格子,
分类讨论发现这两次移动总可以被一次更好的移动直接替代来获取 <span
class="math inline">\(1 \times 2\)</span> 的空地……<br />
  我们从所有的空地出发, 对于所有的躺椅,
从躺椅四周的点往躺椅的一端连一条带权<strong>有向边</strong>表示空地的移动,
跑一遍 <span class="math inline">\(dijkstra\)</span> ,
最后找一下相邻两格的权值和最小值就做完了……<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1754/submission/177711345">link</a><br />
  若把图黑白染色, 也可以把本题看成将图的最大匹配 <span
class="math inline">\(+1\)</span> 所需的最小权值, 看题解评论有人说这个,
不知道能不能做。</p>
<h2 id="codeforces-round-830-div2-221023"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732">Codeforces Round 830 (#Div2)
22/10/23</a></h2>
<p><span class="math inline">\((1816\rightarrow1769,
rk1321)\)</span><br />
这是 10/23 打的第二场比赛, 难度偏高, C1 &gt; D1。糊了个D1, 但 C1, C2
不会, C1 寄了五发, 把上一场加的分全打回去了, 还倒欠 <span
class="math inline">\(10\)</span> 分, 警钟敲烂！</p>
<h3 id="c1c2"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732/problem/C2">C1&amp;C2</a></h3>
<p>题意：<br />
  给你长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span> , <span
class="math inline">\(Q\)</span> 次询问给出 <span
class="math inline">\(L_{i}, R_{i}\)</span> , 让你找出一个子数组 <span
class="math inline">\(a[l,r]\)</span> , 满足 <span
class="math inline">\(L_{i} \leq l \leq r \leq R_{i}\)</span> 且 <span
class="math inline">\(f(l,r)=sum(l,r)-xor(l,r)\)</span> 最大,
有多个最大值时要求 <span class="math inline">\(r-l+1\)</span> 最小,
对于每个询问输出 <span class="math inline">\(l,r\)</span>。<br />
其中 <span
class="math inline">\(sum(l,r)=\sum\limits_{i=l}^{r}{a_{i}}\)</span> ,
<span class="math inline">\(xor(l,r)=a_{l} \oplus a_{l+1} \oplus ...
\oplus a_{r}\)</span> 。<br />
<span class="math inline">\(n \leq 1e5, a_{i} \leq 1e9\)</span> ,
简单版本 <span class="math inline">\(Q=1\)</span> , 困难版本 <span
class="math inline">\(Q=n\)</span> , 钦定 <span
class="math inline">\(L_{1}=1, R_{1}=n\)</span><br />
思路：<br />
<span class="math inline">\(Q=1\)</span>
的情况糊了个二分但是一直错……<br />
  注意到做区间最小 <span class="math inline">\(xor\)</span> 本来是要上
<span class="math inline">\(trie\)</span> 的, 但是考虑每加一个数 <span
class="math inline">\(x\)</span> 时, <span
class="math inline">\(xor\)</span> 的变化一定小于等于 <span
class="math inline">\(sum\)</span> 的增量, 所以有 <span
class="math inline">\(f(l,r) \leq f(l,r+1)\)</span> ,
数组长度越长答案越优, 最大值肯定要选取整个数组,
接下来我们二分长度找到最短长度使得最大值不下降即可。<br />
<span class="math inline">\(Q=n\)</span>
的情况就要利用到一些性质了……<br />
  首先, <span class="math inline">\(0\)</span> 蛋用没有, 没有任何贡献,
还占长度, 答案去掉前导 <span class="math inline">\(0\)</span> 或后缀
<span class="math inline">\(0\)</span> 一定更优。<br />
  假设现在我们选取给定的 <span
class="math inline">\([L_{i},R_{i}]\)</span> 整个子数组,
现在我们考虑什么情况下 <span
class="math inline">\(f(L_{i},R_{i})\)</span> 会减少, 删去一个数, 若
<span class="math inline">\(xor\)</span> 的减量小于 <span
class="math inline">\(sum\)</span> 的减量时更劣,
因此<strong>每个二进制位只能被删除操作覆盖最多一次</strong>,
否则第二次覆盖时 <span class="math inline">\(xor\)</span> 的减量更小(0
-&gt; 1, 或是第一次时就不能覆盖, 0 -&gt; 1), 因为 <span
class="math inline">\(10^9 &lt; 2^{30}\)</span> , 我们只考虑 <span
class="math inline">\([L_{i},R_{i}]\)</span> 内前 <span
class="math inline">\(31\)</span> 个非零数和后 <span
class="math inline">\(31\)</span> 个非 <span
class="math inline">\(0\)</span> 数中选出左右端点即可, 若非 <span
class="math inline">\(0\)</span> 数凑不齐 <span
class="math inline">\(31\)</span> 个……直接双重循环暴力吧……注意特判 <span
class="math inline">\([L_{i},R_{i}]\)</span> 全为 <span
class="math inline">\(0\)</span> 的情况。<br />
  具体实现上, 需要再处理一个非 <span class="math inline">\(0\)</span>
数字数目的前缀和, 以及每个数前面/后面的第一个非 <span
class="math inline">\(0\)</span> 数字。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732/submission/177704957">C1</a>,
<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732/submission/177707161">C2</a><br />
事实上, C1 代码太丑了, 直接看 C2 就行。</p>
<h3 id="d2-4"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732/problem/D2">D2</a></h3>
<p>题意：<br />
  一开始给你一个集合, 只包含 <span class="math inline">\(0\)</span> ,
接下来有 <span class="math inline">\(Q \leq 2e5\)</span> 次操作,
每次操作可能是下列形式的一种 - 往集合中添加 <span
class="math inline">\(x\)</span> - 在集合中删除 <span
class="math inline">\(x\)</span> (保证 <span
class="math inline">\(x\)</span> 已在集合中) - 查询集合的最小未出现过的
<span class="math inline">\(x\)</span> 的倍数(x-mex)</p>
<p>  D1 没有删除操作, 你直接记忆化暴力, 用一个 <span
class="math inline">\(last[k]\)</span> 存储上一次询问 k-mex 的答案,
下次再询问到时从那儿再更新就行了, 有删除操作时我们也可以仿照 D1。<br />
  具体地, 我们开一个 map&lt;int,set<int>&gt; del; 来用 <span
class="math inline">\(del[x]\)</span> 表示 <span
class="math inline">\(x\)</span> 未出现的倍数, 再开一个
map&lt;int,vector<int>&gt; change; 用 <span
class="math inline">\(change[x]\)</span> 来表示删除 <span
class="math inline">\(x\)</span> 后改变了哪些数的 <span
class="math inline">\(last\)</span> , 询问的时候更新 <span
class="math inline">\(last\)</span> 的时候顺带更新 <span
class="math inline">\(change\)</span> 就好了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1732/submission/177738198">link</a><br />
有点抽象……</p>
<h2 id="codeforces-round-831-div.-1-div.-2-221029"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1740">Codeforces Round #831 (Div. 1
+ Div. 2) 22/10/29</a></h2>
<p><span class="math inline">\((1769\rightarrow1819,
rk712)\)</span><br />
第一次场上做出 E, 泪目, 虽然这个 E 只有 1800……</p>
<h3 id="f-18"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1740/problem/F">F</a></h3>
<p>题意：<br />
  给你一个含有 <span class="math inline">\(n \leq 2000\)</span>
个整数的数组 <span class="math inline">\(a(1 \leq a_{i} \leq n)\)</span>
, 对于每个 <span class="math inline">\(a_{i}\)</span> 添加一个元素集
<span class="math inline">\(\{a_{i}\}\)</span><br />
定义一次操作由以下两步构成：<br />
- 选择两个集合 <span class="math inline">\(S, T\)</span> , 满足 <span
class="math inline">\(S \cap T = \emptyset\)</span> - 删除集合 <span
class="math inline">\(S, T\)</span> , 添加集合 <span
class="math inline">\(S \cup T\)</span></p>
<p>  在进行 <span class="math inline">\(0\)</span> 次或多次操作后,
我们构造一个<strong>可重</strong>集合 <span
class="math inline">\(M\)</span> 表示当前剩下的所有集合的大小。举个例子,
若当前剩下的集合为 <span class="math inline">\(\{5\}, \{8\},
\{2,5,12,4\}\)</span> , 则 <span class="math inline">\(M\)</span> 为
<span class="math inline">\(\{1,1,4\}\)</span> 。现在让你求出所有不同的
<span class="math inline">\(M\)</span> 的数量, 对 <span
class="math inline">\(998244353\)</span> 取模。<br />
思路：<br />
让我们层层推进。<br />
1、所有的 <span class="math inline">\(M\)</span> 集合都可以通过在后面补
<span class="math inline">\(0\)</span> 变成大小为 <span
class="math inline">\(n\)</span> 的集合, 记 <span
class="math inline">\(M\)</span> 集合中的元素为 <span
class="math inline">\(m_{1}, m_{2}, m_{3}, ..., m_{n}\)</span> ,
让我们以 <span class="math inline">\(m_{1} \geq m_{2} \geq m_3 \geq ...
\geq m_{n} \geq 0\)</span> 为 <span class="math inline">\(M\)</span>
中的元素排序, 直觉告诉我们, 一个 "更大" 的合法集合如 <span
class="math inline">\(M=\{11,3,2,1,0,0...\}\)</span> 可以直接拆成 "更小"
的合法集合, 如 <span
class="math inline">\(M&#39;=\{6,5,3,2,1,0,0...\}\)</span><br />
2、现在定义何为 "更大" , 令 <span class="math inline">\(M\)</span>
为原集合的前缀和集合, <span class="math inline">\(\{11,3,2,1,0,0...\}
\Rightarrow \{11,14,16,17,17,17...\}\)</span> 。 对于两个集合 <span
class="math inline">\(M, M&#39;\)</span> , 若 <span
class="math inline">\(\forall\;i \in [1,n], m_{i} \geq
m&#39;_{i}\)</span> 则 <span class="math inline">\(M\)</span>
更大。<br />
3、记 <span class="math inline">\(cnt_{i}\)</span> 为 <span
class="math inline">\(a\)</span> 数组中数字 <span
class="math inline">\(i\)</span> 出现的次数, 可以看出来, "最大"
的集合只有一个, 我们把出现过一次及以上的数的个数记为 <span
class="math inline">\(m_{1}\)</span> , 出现过两次及以上的数的个数记为
<span class="math inline">\(m_{2}\)</span> …… 这样我们可以定义出 <span
class="math inline">\(M\)</span> , 若按照刚刚的前缀和的定义,<br />
<span class="math display">\[m_{i}=
\sum\limits_{j=1}^{n}{min(cnt_{j},i)}\]</span><br />
(注意上文的 <span class="math inline">\(j\)</span> <strong>不是</strong>
<span class="math inline">\(a_{j}\)</span>)<br />
现在回到原始定义, 那么一个合法的 <span class="math inline">\(M\)</span>
集合就要满足：<br />
<span class="math display">\[\forall k \in [1,n],
\sum\limits_{i=1}^{k}{m_{i}} \leq \sum\limits_{j=1}^{n}{min(cnt_{j},k)}
\;\;and\;\; \sum\limits_{i=1}^{n}{m_{i}}=n\]</span><br />
我们考虑进行 DP 。<br />
4、设 <span
class="math inline">\(lim[i]=\sum\limits_{j=1}^{n}{min(cnt_{j},i)}\)</span>
, 我们考虑一个三维的 <span class="math inline">\(f[p][sum][las]\)</span>
表示 <span class="math inline">\(M\)</span> 已经填了 <span
class="math inline">\(p\)</span> 位, <span
class="math inline">\(p\)</span> 位的和为 <span
class="math inline">\(sum\)</span> , 第 <span
class="math inline">\(p\)</span> 位(最后一位)为 <span
class="math inline">\(las\)</span> 时的方案数, 则有如下转移：<br />
<span class="math display">\[f[p][sum][las]=\sum f[p-1][sum-x][x], x
\geq las, sum \leq lim[p]\]</span><br />
<span class="math inline">\(x \geq las\)</span> 是因为 <span
class="math inline">\(m_{1}, m_{2}, ..., m_{n}\)</span> 单调不降,
转移后再令：<br />
<span
class="math display">\[f[p][sum][las]=\sum\limits_{i=las}^{n}{f[p][sum][i]}\]</span><br />
做后缀和可以把 <span class="math inline">\(O(n^4)\)</span> 的复杂度降到
<span class="math inline">\(O(n^3)\)</span> ,
空间复杂度可以通过滚动数组降到 <span
class="math inline">\(O(n^2)\)</span> , 然而 <span
class="math inline">\(O(n^3)\)</span>
的时间复杂度还是无法通过本题。<br />
5、考虑 <span class="math inline">\(las\)</span> 作为最后一个数, 有
<span class="math inline">\(n \geq p *las\)</span> , 所以 <span
class="math inline">\(las \leq n/p\)</span> , 总的复杂度为调和级数形式,
<span class="math inline">\(O(n*n \; \log \; n)=O(n^2\;log\;n)\)</span>
。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1740/submission/178757068">link</a><br />
  因为本题的转移在前缀和优化后其实就是一个 <span
class="math inline">\(O(1)\)</span> 的赋值,
我的滚动数组会出现奇奇怪怪的错误, 就直接开两个数组 <span
class="math inline">\(f, g\)</span> 了, 同时后缀和的开头要大一点,
要让后面的完全覆盖前面的值, 同时注意 <span
class="math inline">\(g\)</span> 数组的初始化……</p>
<h2 id="codeforces-round-832-div2-22114"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1747">Codeforces Round 832 (#Div2)
22/11/4</a></h2>
<p><span class="math inline">\((1819\rightarrow1792,
rk1231)\)</span><br />
进行一个烂的摆, D不会, A, B各吃一发罚时, 寄。</p>
<h3 id="d-18"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1747/problem/D">D</a></h3>
<p>题意：<br />
长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span> , <span
class="math inline">\(Q\)</span> 次独立询问, 每次询问给出一个 <span
class="math inline">\([L_{i},R_{i}]\)</span> 区间,
你可以在区间内进行任意次操作：<br />
-选择 <span class="math inline">\(l, r (L_{i} \leq l \leq r \leq
R_{i})\)</span> 且 <span class="math inline">\(r-l+1\)</span>
为奇数<br />
-将 <span class="math inline">\(a_{l}, a_{l+1}, ..., a_{r}\)</span>
赋值为 <span class="math inline">\(a_{l} \oplus a_{l+1} \oplus ...
\oplus a_{r}\)</span><br />
问能将 <span class="math inline">\(a[L_{i},R_{i}]\)</span> 区间整体置
<span class="math inline">\(0\)</span> 的最小操作次数, 或输出 <span
class="math inline">\(-1\)</span> 表示不可能。<br />
<span class="math inline">\(n, Q \leq 2e5, 1 \leq a_{i} \leq
2^{30}\)</span><br />
思路：<br />
寄！就差最后一步……<br />
若区间异或和不为 <span class="math inline">\(0\)</span> , 直接输出 <span
class="math inline">\(-1\)</span> 。<br />
若区间全为 <span class="math inline">\(0\)</span> , 直接输出 <span
class="math inline">\(0\)</span> 。<br />
若区间长度为奇数, 我们可以直接操作整个区间, 输出 <span
class="math inline">\(1\)</span> 。<br />
若 <span class="math inline">\(a[L_{i}]=0\)</span> 或 <span
class="math inline">\(a[R_{i}]=0\)</span> , 我们可以忽略这一个长度,
然后输出 <span class="math inline">\(-1\)</span> 同上。<br />
<strong>重点</strong> , 若以 <span
class="math inline">\(a[R_{i}]\)</span> 为右端点, 存在某一段区间异或和为
<span class="math inline">\(0\)</span> 且这段区间的左端点 <span
class="math inline">\(lb \geq L_{i}\)</span> 且 <span
class="math inline">\(lb\)</span> 与 <span
class="math inline">\(R_{i}\)</span> 奇偶性相同, 输出 <span
class="math inline">\(2\)</span> 。<br />
否则剩余情况输出 <span class="math inline">\(-1\)</span> 。<br />
若答案 <span class="math inline">\(\geq 3\)</span> ,
中间的区间一定能被并入两边区间, 你可以手玩一下,
若中间的并入两边的某一个区间后新的区间长度为奇数就正好,
若并上两边的区间长度都为偶数我们就直接三个区间并在一起。<br />
我们维护以一个点为右端点的最小的异或和为 <span
class="math inline">\(0\)</span> 的区间, 只要开一个 二维 <span
class="math inline">\(map\)</span> , 第一维大小为 2,
来回跳就可以了。<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1747/submission/179289879">link</a></p>
<h3 id="e-26"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1747/problem/E">E</a></h3>
<p>2900 的 E, 补你**</p>
<h2 id="codeton-round-3-div.1div.2-22116"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1750">CodeTON Round 3 (Div.1+Div.2)
22/11/6</a></h2>
<p><span class="math inline">\((1792\rightarrow1732,
rk2536)\)</span><br />
思维僵化, 手速慢, 吃罚时, C写了三遍……, D 看错一个范围(<span
class="math inline">\(a_{i} \leq m \Rightarrow a_{i} \leq n\)</span>),
进行一个分数回调, 从来不开窍, 我癫都懒得发了。</p>
<h3 id="e-27"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1750/problem/E">E</a></h3>
<p>题意：<br />
给你一个长度为 <span class="math inline">\(n(n \leq 2e5)\)</span>
的括号序列, 问你将它的所有(<span
class="math inline">\(n*(n+1)/2\)</span>)
的子串变为合法括号序列的最少操作数之和。你有两种操作可用,
分别是选择子串循环右移一格以及插入一个任意括号。<br />
思路：<br />
经典括号匹配问题, 对于一个合法括号序列, 记 <span
class="math inline">\((\)</span> 为 <span
class="math inline">\(+1\)</span>, <span
class="math inline">\()\)</span> 为 <span
class="math inline">\(-1\)</span> , 它的前缀和不能掉到 <span
class="math inline">\(0\)</span> 以下且总和为 <span
class="math inline">\(0\)</span>。<br />
首先, 因为总和必须为 <span class="math inline">\(0\)</span> ,
要加的左右括号数是确定的。<br />
然后？然后不会了。<br />
使用 codeforces 题解评论区 <span
class="math inline">\(\color{orange}{\tt{adamant}}\)</span>
的解法：<br />
一个可以手玩出的结论是, 设一个括号序列的最小前缀和为 <span
class="math inline">\(m(m \leq 0)\)</span>, 总和为 <span
class="math inline">\(c\)</span> , 需要的最小操作总数为 <span
class="math inline">\(|m|+max(0,c)\)</span>
。可以这么考虑：不管最后哪种括号更多, 中间前缀和小于 <span
class="math inline">\(0\)</span> 的部分都要通过找一个末尾为 <span
class="math inline">\((\)</span> 的子串右移来把前缀和 "拉上来",
右括号更多就可以虚空造左括号来拉前缀和,
左括号更多在拉完前缀和后还要造更多的右括号使得总和为 <span
class="math inline">\(0\)</span>。<br />
我们记这个括号序列为 <span class="math inline">\(s=(m;c)\)</span> ,
现在考虑分治的思想, 对于括号序列 <span
class="math inline">\(s_{1}=(m_{1};c_{1}), s_{2}=(m_{2};c_{2}),
s_{1}+s_{2}=(min(m_{1},c_{1}+m_{2});c_{1}+c_{2})\)</span> 左边的 <span
class="math inline">\(min\)</span> 表示最小前缀和 <span
class="math inline">\(m\)</span> 要么出现在 <span
class="math inline">\(s_{1}\)</span> 中, 要么出现在 <span
class="math inline">\(s_{2}\)</span> 中。<br />
现在考虑怎么做这个分治, 先把括号序列分为左右两部分(<span
class="math inline">\([0,mid),[mid,n]\)</span>),
算好子串在单个部分内的贡献, 再算子串跨部分的贡献(下文 <span
class="math inline">\(c_{1}, c_{2}\)</span> 等来自 <span
class="math inline">\(s_{1}=[start,mid), s_{2}=[mid,p]\)</span>
两个子串)。<br />
枚举左边的每个括号作为子串的起点, 按照 <span
class="math inline">\(c\)</span> 将右边排序, 找到最远的终点使得 <span
class="math inline">\(c_{1}+c_{2} \leq 0\)</span> , 这样左边的子串的
<span class="math inline">\(c\)</span> 贡献为 <span
class="math inline">\(0\)</span>, 右边的子串的 <span
class="math inline">\(c\)</span> 贡献为 <span
class="math inline">\(c_{1}+c_{2}\)</span>。<br />
枚举左边的每个括号作为子串的起点, 按照 <span
class="math inline">\(m\)</span> 将右边排序, 找到最远的终点使得 <span
class="math inline">\(m_{2} \leq m_{1} - c_{1}\)</span> ,
这样左边的子串的 <span class="math inline">\(m\)</span> 贡献为 <span
class="math inline">\(|m_{2}+c_{1}|\)</span>, 右边的子串的 <span
class="math inline">\(m\)</span> 贡献为 <span
class="math inline">\(|m_{1}|\)</span>, 不用担心绝对值符号, 因为取 <span
class="math inline">\(|m_{2}+c_{1}|\)</span> 时, <span
class="math inline">\(m_{2}+c_{1} \leq m_{1} \leq 0\)</span>。<br />
于是应该做完了……<br />
代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1750/submission/179974018">link</a><br />
虽然有点复杂, 但也是一种做法嘛……<br />
注意代码里前缀后缀满天飞……我尽量注释好了……<br />
复杂度是 <span class="math inline">\(O(n log^2 n)\)</span> 的吧……</p>
<h2 id="codeforces-round-832-div2-221112"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1748">Codeforces Round 832 (#Div2)
22/11/12</a></h2>
<p><span class="math inline">\((1731\rightarrow1801,
rk374)\)</span><br />
最后糊出了D, 好起来了。</p>
<h3 id="e-28"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1748/problem/E">E</a></h3>
<p>笛卡尔树, 不会</p>
<h3 id="f-19"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1748/problem/F">F</a></h3>
<p>构造, 摆<br />
今天的补题就到这里了, 大家下场再见</p>
<h2 id="pinely-round-1-div.-1-div.-2-221120"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1761">Pinely Round 1 (Div. 1 + Div.
2) 22/11/20</a></h2>
<p><span class="math inline">\((1801\rightarrow1906,
rk460)\)</span><br />
上紫了！运气真的很好！<br />
ABC 差不多手速拉满 + 0 dirt<br />
D 在赛时的最后 15 mins 才冲出来, 没有 ABC
的手速和上午刚打的数论小板子我这样的菜鸡估计会寄在 China Round 的 D,
最后贴线上紫。<br />
成功在 NOIP 前最后一场比赛完成退役前上紫的既定目标, 现在别无所求, NOIP
随便打了。</p>
<h3 id="e-29"><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1761/problem/E">E</a></h3>
<p>题意：<br />
通过 01矩阵 给你一个 <span class="math inline">\(n \leq 4000\)</span>
节点的无向图, 问你需要至少多少次操作才能让图联通,
每次操作是这样的：<br />
- 任意选择一个 <span class="math inline">\(u\)</span> 节点 -
对于剩余的所有节点, 如果有 u-v 边, 就断掉, 否则就加上</p>
<p>要求输出最少操作次数和操作序列。<br />
思路：<br />
考虑一下什么时候答案为 <span class="math inline">\(1\)</span> ,
当场上有孤立点时, 直接操作那个孤立点就行。 我们可以得出一个粗糙的策略,
找到度数最小的点并通过操作与它相邻的所有点把那个点独立,
最后操作那个点。<br />
这个结论对于 E 而言太过简单, 我们想一想反例, 在一个联通块(大小为
siz)中若出现一个度数不为 siz-1 的点, 我们可以直接操作这个点一次,
虽然它的边会断掉, 但它还能连回联通块, 而且也可以连上其他的所有点：<br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/gbefwi7d.png" /><br />
<img
src="https://cdn.luogu.com.cn/upload/image_hosting/49dv0by4.png" /><br />
就像这样。 我们还可以发现, 我们不用“死扣一个点”,
如果场上有三个及以上联通块, 我们可以在 1, 3 联通块中任意取一个点出来,
这样保证联通块 2 与其他联通块相联通, 只要两次操作。<br />
当场上只有两个联通块, 内部是完全图(团)的时候,
我们对于节点的操作就相当于把一个节点从一个图拉到了另一个图中, 答案为
min(siz1,siz2)<br />
总结一下零零散散的性质：</p>
<ol type="1">
<li><p>图已联通时(联通块数量为 <span class="math inline">\(1\)</span>
)答案为 <span class="math inline">\(0\)</span></p></li>
<li><p>有孤立点时答案为 <span class="math inline">\(1\)</span> ,
选择那个孤立点</p></li>
<li><p>若存在某个联通块内部不是完全图(团)的时候选择其中度数最小的节点,
答案为 <span class="math inline">\(1\)</span></p></li>
<li><p>若有两个联通块, 答案为 <span
class="math inline">\(min(siz_{1},siz_{2})\)</span> ,
输出较小联通块内的所有节点</p></li>
<li><p>若有三个及以上联通块, 答案为 <span
class="math inline">\(2\)</span> , 任选两个联通块,
各挑一个点输出。</p></li>
</ol>
<p>代码：<a
target="_blank" rel="noopener" href="https://codeforces.com/contest/1761/submission/181833388">link</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Codeforces exercises 2022</p><p><a href="http://example.com/2024/07/05/Codeforces-exercises-2022/">http://example.com/2024/07/05/Codeforces-exercises-2022/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Frankly6</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2024-07-05</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2025-03-27</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><hr style="height:1px;margin:1rem 0"><div class="level is-mobile is-flex"><div class="article-tags is-size-7 is-uppercase"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted" rel="tag" href="/tags/C/">C++, </a><a class="link-muted" rel="tag" href="/tags/%E7%BC%96%E7%A8%8B%E7%AB%9E%E8%B5%9B/">编程竞赛 </a></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2025/01/05/Codeforces-exercises-2024/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Codeforces exercises 2024</span></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level" style="margin-bottom:1rem"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Frankly6"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Frankly6</p></div></div></nav><nav class="level menu-list is-mobile" style="margin-bottom:1rem"><a class="level-item has-text-centered is-marginless" href="/archives/"><div><p class="heading">文章</p><div><p class="title">5</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/categories/"><div><p class="heading">分类</p><div><p class="title">3</p></div></div></a><a class="level-item has-text-centered is-marginless" href="/tags/"><div><p class="heading">标签</p><div><p class="title">6</p></div></div></a></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="level is-mobile" href="#codeforces-round-795-div2-22531"><span class="level-left"><span class="level-item">1</span><span class="level-item">codeforces round 795 (#Div2)
22/5/31</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-796-div2-2263"><span class="level-left"><span class="level-item">2</span><span class="level-item">codeforces round 796 (#Div2)
22/6/3</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-div1-b"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">E (Div1 B)</span></span></a></li><li><a class="level is-mobile" href="#f-div1-c"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">F (Div1 C)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-800-div2-22616"><span class="level-left"><span class="level-item">3</span><span class="level-item">codeforces round 800 (#Div2)
22/6/16</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-div1-c"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">E (Div1 C)</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-801-div2-22618"><span class="level-left"><span class="level-item">4</span><span class="level-item">codeforces round 801 (#Div2)
22/6/18</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d1"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">D1</span></span></a></li><li><a class="level is-mobile" href="#d2"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">D2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-131-div2-2278"><span class="level-left"><span class="level-item">5</span><span class="level-item">Educational codeforces round
131 (#Div2) 22/7/8</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-1"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-1"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-808-div2-22716"><span class="level-left"><span class="level-item">6</span><span class="level-item">codeforces round 808 (#Div2)
22/7/16</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c"><span class="level-left"><span class="level-item">6.1</span><span class="level-item">C</span></span></a></li><li><a class="level is-mobile" href="#d-2"><span class="level-left"><span class="level-item">6.2</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-2"><span class="level-left"><span class="level-item">6.3</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-809-div2-22718"><span class="level-left"><span class="level-item">7</span><span class="level-item">codeforces round 809 (#Div2)
22/7/18</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d2-1"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">D2</span></span></a></li><li><a class="level is-mobile" href="#e-3"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-132-div2-22721"><span class="level-left"><span class="level-item">8</span><span class="level-item">Educational codeforces round
132 (#Div2) 22/7/21</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c-1"><span class="level-left"><span class="level-item">8.1</span><span class="level-item">C</span></span></a></li><li><a class="level is-mobile" href="#e-4"><span class="level-left"><span class="level-item">8.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-810-div2-22724"><span class="level-left"><span class="level-item">9</span><span class="level-item">codeforces round 810 (#Div2)
22/7/24</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-3"><span class="level-left"><span class="level-item">9.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-5"><span class="level-left"><span class="level-item">9.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeton-round-2-div12-22731"><span class="level-left"><span class="level-item">10</span><span class="level-item">codeTON Round 2 (#Div1+2)
22/7/31</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-4"><span class="level-left"><span class="level-item">10.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-6"><span class="level-left"><span class="level-item">10.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-1"><span class="level-left"><span class="level-item">10.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-133-div2-2284"><span class="level-left"><span class="level-item">11</span><span class="level-item">Educational codeforces round
133 (#Div2) 22/8/4</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-5"><span class="level-left"><span class="level-item">11.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-7"><span class="level-left"><span class="level-item">11.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-2"><span class="level-left"><span class="level-item">11.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-812-div2-2286"><span class="level-left"><span class="level-item">12</span><span class="level-item">Codeforces round 812 (#Div2)
22/8/6</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d交互"><span class="level-left"><span class="level-item">12.1</span><span class="level-item">D(交互)</span></span></a></li><li><a class="level is-mobile" href="#e-8"><span class="level-left"><span class="level-item">12.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-3"><span class="level-left"><span class="level-item">12.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-813-div2-22813"><span class="level-left"><span class="level-item">13</span><span class="level-item">Codeforces round 813 (#Div2)
22/8/13</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-6"><span class="level-left"><span class="level-item">13.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e1"><span class="level-left"><span class="level-item">13.2</span><span class="level-item">E1</span></span></a></li><li><a class="level is-mobile" href="#e2"><span class="level-left"><span class="level-item">13.3</span><span class="level-item">E2</span></span></a></li><li><a class="level is-mobile" href="#f-4"><span class="level-left"><span class="level-item">13.4</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-814-div2-22816"><span class="level-left"><span class="level-item">14</span><span class="level-item">Codeforces round 814 (#Div2)
22/8/16</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d2-2"><span class="level-left"><span class="level-item">14.1</span><span class="level-item">D2</span></span></a></li><li><a class="level is-mobile" href="#e-9"><span class="level-left"><span class="level-item">14.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-5"><span class="level-left"><span class="level-item">14.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-816-div2-22820"><span class="level-left"><span class="level-item">15</span><span class="level-item">Codeforces round 816 (#Div2)
22/8/20</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-7"><span class="level-left"><span class="level-item">15.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-10"><span class="level-left"><span class="level-item">15.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-6"><span class="level-left"><span class="level-item">15.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-134-div2-22827"><span class="level-left"><span class="level-item">16</span><span class="level-item">Educational codeforces round
134 (#Div2) 22/8/27</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-8"><span class="level-left"><span class="level-item">16.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-11"><span class="level-left"><span class="level-item">16.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-7"><span class="level-left"><span class="level-item">16.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-818-div2-2292"><span class="level-left"><span class="level-item">17</span><span class="level-item">Codeforces round 818 (#Div2)
22/9/2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-12"><span class="level-left"><span class="level-item">17.1</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-8"><span class="level-left"><span class="level-item">17.2</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-819-div12-2296"><span class="level-left"><span class="level-item">18</span><span class="level-item">Codeforces round 819
(#Div1+2) 22/9/6</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-9"><span class="level-left"><span class="level-item">18.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-13"><span class="level-left"><span class="level-item">18.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-136-div2-2298"><span class="level-left"><span class="level-item">19</span><span class="level-item">Educational codeforces round
136 (#Div2) 22/9/8</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-10"><span class="level-left"><span class="level-item">19.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-14"><span class="level-left"><span class="level-item">19.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-9"><span class="level-left"><span class="level-item">19.3</span><span class="level-item">F</span></span></a></li><li><a class="level is-mobile" href="#g"><span class="level-left"><span class="level-item">19.4</span><span class="level-item">G</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-821-div2-22919"><span class="level-left"><span class="level-item">20</span><span class="level-item">Codeforces round 821 (#Div2)
22/9/19</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d2-3"><span class="level-left"><span class="level-item">20.1</span><span class="level-item">D2</span></span></a></li><li><a class="level is-mobile" href="#e-15"><span class="level-left"><span class="level-item">20.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-822-div2-22923"><span class="level-left"><span class="level-item">21</span><span class="level-item">Codeforces Round 822 (#Div2)
22/9/23</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-16"><span class="level-left"><span class="level-item">21.1</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-10"><span class="level-left"><span class="level-item">21.2</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-823-div2-22925"><span class="level-left"><span class="level-item">22</span><span class="level-item">Codeforces Round 823 (#Div2)
22/9/25</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c-2"><span class="level-left"><span class="level-item">22.1</span><span class="level-item">C</span></span></a></li><li><a class="level is-mobile" href="#d-11"><span class="level-left"><span class="level-item">22.2</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-17"><span class="level-left"><span class="level-item">22.3</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-11"><span class="level-left"><span class="level-item">22.4</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-136-div2-22929"><span class="level-left"><span class="level-item">23</span><span class="level-item">Educational Codeforces Round
136 (#Div2) 22/9/29</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-12"><span class="level-left"><span class="level-item">23.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-18"><span class="level-left"><span class="level-item">23.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-12"><span class="level-left"><span class="level-item">23.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-global-round-22-22930"><span class="level-left"><span class="level-item">24</span><span class="level-item">Codeforces Global Round 22
22/9/30</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c-3"><span class="level-left"><span class="level-item">24.1</span><span class="level-item">C</span></span></a></li><li><a class="level is-mobile" href="#d-13"><span class="level-left"><span class="level-item">24.2</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-19"><span class="level-left"><span class="level-item">24.3</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-13"><span class="level-left"><span class="level-item">24.4</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-824-div2-22102"><span class="level-left"><span class="level-item">25</span><span class="level-item">Codeforces Round 824 (#Div2)
22/10/2</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-14"><span class="level-left"><span class="level-item">25.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-20"><span class="level-left"><span class="level-item">25.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-14"><span class="level-left"><span class="level-item">25.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#dytechlab-cup-2022-22107"><span class="level-left"><span class="level-item">26</span><span class="level-item">Dytechlab Cup 2022
22/10/7</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-15"><span class="level-left"><span class="level-item">26.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-21"><span class="level-left"><span class="level-item">26.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-825-div2-221010"><span class="level-left"><span class="level-item">27</span><span class="level-item">Codeforces Round 825 (#Div2)
22/10/10</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c2"><span class="level-left"><span class="level-item">27.1</span><span class="level-item">C2</span></span></a></li><li><a class="level is-mobile" href="#e-22"><span class="level-left"><span class="level-item">27.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-global-round-23-221015"><span class="level-left"><span class="level-item">28</span><span class="level-item">Codeforces Global Round 23
22/10/15</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-16"><span class="level-left"><span class="level-item">28.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e1-1"><span class="level-left"><span class="level-item">28.2</span><span class="level-item">E1</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-137-div2-221017"><span class="level-left"><span class="level-item">29</span><span class="level-item">Educational Codeforces Round
137 (#Div2) 22/10/17</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-23"><span class="level-left"><span class="level-item">29.1</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-15"><span class="level-left"><span class="level-item">29.2</span><span class="level-item">F</span></span></a></li><li><a class="level is-mobile" href="#g-1"><span class="level-left"><span class="level-item">29.3</span><span class="level-item">G</span></span></a></li></ul></li><li><a class="level is-mobile" href="#educational-codeforces-round-138-div2-221020"><span class="level-left"><span class="level-item">30</span><span class="level-item">Educational Codeforces Round
138 (#Div2) 22/10/20</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-17"><span class="level-left"><span class="level-item">30.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-24"><span class="level-left"><span class="level-item">30.2</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-16"><span class="level-left"><span class="level-item">30.3</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-829-div2-221023"><span class="level-left"><span class="level-item">31</span><span class="level-item">Codeforces Round 829 (#Div2)
22/10/23</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-25"><span class="level-left"><span class="level-item">31.1</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-17"><span class="level-left"><span class="level-item">31.2</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-830-div2-221023"><span class="level-left"><span class="level-item">32</span><span class="level-item">Codeforces Round 830 (#Div2)
22/10/23</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#c1c2"><span class="level-left"><span class="level-item">32.1</span><span class="level-item">C1&amp;C2</span></span></a></li><li><a class="level is-mobile" href="#d2-4"><span class="level-left"><span class="level-item">32.2</span><span class="level-item">D2</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-831-div.-1-div.-2-221029"><span class="level-left"><span class="level-item">33</span><span class="level-item">Codeforces Round #831 (Div. 1
+ Div. 2) 22/10/29</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#f-18"><span class="level-left"><span class="level-item">33.1</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-832-div2-22114"><span class="level-left"><span class="level-item">34</span><span class="level-item">Codeforces Round 832 (#Div2)
22/11/4</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#d-18"><span class="level-left"><span class="level-item">34.1</span><span class="level-item">D</span></span></a></li><li><a class="level is-mobile" href="#e-26"><span class="level-left"><span class="level-item">34.2</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeton-round-3-div.1div.2-22116"><span class="level-left"><span class="level-item">35</span><span class="level-item">CodeTON Round 3 (Div.1+Div.2)
22/11/6</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-27"><span class="level-left"><span class="level-item">35.1</span><span class="level-item">E</span></span></a></li></ul></li><li><a class="level is-mobile" href="#codeforces-round-832-div2-221112"><span class="level-left"><span class="level-item">36</span><span class="level-item">Codeforces Round 832 (#Div2)
22/11/12</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-28"><span class="level-left"><span class="level-item">36.1</span><span class="level-item">E</span></span></a></li><li><a class="level is-mobile" href="#f-19"><span class="level-left"><span class="level-item">36.2</span><span class="level-item">F</span></span></a></li></ul></li><li><a class="level is-mobile" href="#pinely-round-1-div.-1-div.-2-221120"><span class="level-left"><span class="level-item">37</span><span class="level-item">Pinely Round 1 (Div. 1 + Div.
2) 22/11/20</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#e-29"><span class="level-left"><span class="level-item">37.1</span><span class="level-item">E</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="frankly6" height="28"></a><p class="is-size-7"><span>&copy; 2025 Frankly6</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a><br><span id="busuanzi_container_site_uv">共<span id="busuanzi_value_site_uv">0</span>个访客</span></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-cn");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script data-pjax src="/js/column.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script data-pjax src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.10.0/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.8.1/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/javascript" id="MathJax-script" async>MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']]
      },
      svg: {
        fontCache: 'global'
      },
      chtml: {
        matchFontHeight: false
      }
    };</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js"></script><script src="https://cdnjs.loli.net/ajax/libs/pjax/0.2.8/pjax.min.js"></script><script src="/js/pjax.js"></script><!--!--><!--!--><!--!--><script data-pjax src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script data-pjax src="/js/insight.js" defer></script><script data-pjax>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>